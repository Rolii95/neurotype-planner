-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:24:57.219Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
CREATE VIEW routine_analytics_view AS
WITH routine_stats AS (
  SELECT
    user_id,
    COUNT(*) AS total_routines,
    COALESCE(SUM(total_duration), 0) AS total_minutes,
    COUNT(DISTINCT DATE(started_at)) AS days_tracked,
    MAX(DATE(started_at)) AS last_tracked_date
  FROM routine_executions
  GROUP BY user_id
),
step_stats AS (
  SELECT
    re.user_id,
    COUNT(*) FILTER (WHERE se.status = 'completed') AS total_steps,
    COALESCE(SUM(COALESCE(se.actual_duration, 0)), 0) AS total_step_minutes
  FROM step_executions se
  INNER JOIN routine_executions re ON re.id = se.routine_execution_id
  GROUP BY re.user_id
)
SELECT
  rs.user_id,
  rs.total_routines,
  COALESCE(ss.total_steps, 0) AS total_steps,
  rs.total_minutes,
  COALESCE(ss.total_step_minutes, 0) AS total_step_minutes,
  rs.days_tracked,
  rs.last_tracked_date
FROM routine_stats rs
LEFT JOIN step_stats ss ON ss.user_id = rs.user_id;

-- Grant usage via existing RLS policies on the underlying tables
GRANT SELECT ON routine_analytics_view TO authenticated;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:23:49.282Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:22:54.692Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
CREATE VIEW routine_analytics_view AS
WITH routine_stats AS (
  SELECT
    user_id,
    COUNT(*) AS total_routines,
    COALESCE(SUM(total_duration), 0) AS total_minutes,
    COUNT(DISTINCT DATE(started_at)) AS days_tracked,
    MAX(DATE(started_at)) AS last_tracked_date
  FROM routine_executions
  GROUP BY user_id
),
step_stats AS (
  SELECT
    re.user_id,
    COUNT(*) FILTER (WHERE se.status = 'completed') AS total_steps,
    COALESCE(SUM(COALESCE(se.actual_duration, 0)), 0) AS total_step_minutes
  FROM step_executions se
  INNER JOIN routine_executions re ON re.id = se.routine_execution_id
  GROUP BY re.user_id
)
SELECT
  rs.user_id,
  rs.total_routines,
  COALESCE(ss.total_steps, 0) AS total_steps,
  rs.total_minutes,
  COALESCE(ss.total_step_minutes, 0) AS total_step_minutes,
  rs.days_tracked,
  rs.last_tracked_date
FROM routine_stats rs
LEFT JOIN step_stats ss ON ss.user_id = rs.user_id;

-- Grant usage via existing RLS policies on the underlying tables
GRANT SELECT ON routine_analytics_view TO authenticated;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:22:06.485Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:19:51.685Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
CREATE VIEW routine_analytics_view AS
WITH routine_stats AS (
  SELECT
    user_id,
    COUNT(*) AS total_routines,
    COALESCE(SUM(total_duration), 0) AS total_minutes,
    COUNT(DISTINCT DATE(started_at)) AS days_tracked,
    MAX(DATE(started_at)) AS last_tracked_date
  FROM routine_executions
  GROUP BY user_id
),
step_stats AS (
  SELECT
    re.user_id,
    COUNT(*) FILTER (WHERE se.status = 'completed') AS total_steps,
    COALESCE(SUM(COALESCE(se.actual_duration, 0)), 0) AS total_step_minutes
  FROM step_executions se
  INNER JOIN routine_executions re ON re.id = se.routine_execution_id
  GROUP BY re.user_id
)
SELECT
  rs.user_id,
  rs.total_routines,
  COALESCE(ss.total_steps, 0) AS total_steps,
  rs.total_minutes,
  COALESCE(ss.total_step_minutes, 0) AS total_step_minutes,
  rs.days_tracked,
  rs.last_tracked_date
FROM routine_stats rs
LEFT JOIN step_stats ss ON ss.user_id = rs.user_id;

-- Grant usage via existing RLS policies on the underlying tables
GRANT SELECT ON routine_analytics_view TO authenticated;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:19:23.101Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:14:46.503Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
CREATE VIEW routine_analytics_view AS
WITH routine_stats AS (
  SELECT
    user_id,
    COUNT(*) AS total_routines,
    COALESCE(SUM(total_duration), 0) AS total_minutes,
    COUNT(DISTINCT DATE(started_at)) AS days_tracked,
    MAX(DATE(started_at)) AS last_tracked_date
  FROM routine_executions
  GROUP BY user_id
),
step_stats AS (
  SELECT
    re.user_id,
    COUNT(*) FILTER (WHERE se.status = 'completed') AS total_steps,
    COALESCE(SUM(COALESCE(se.actual_duration, 0)), 0) AS total_step_minutes
  FROM step_executions se
  INNER JOIN routine_executions re ON re.id = se.routine_execution_id
  GROUP BY re.user_id
)
SELECT
  rs.user_id,
  rs.total_routines,
  COALESCE(ss.total_steps, 0) AS total_steps,
  rs.total_minutes,
  COALESCE(ss.total_step_minutes, 0) AS total_step_minutes,
  rs.days_tracked,
  rs.last_tracked_date
FROM routine_stats rs
LEFT JOIN step_stats ss ON ss.user_id = rs.user_id;

-- Grant usage via existing RLS policies on the underlying tables
GRANT SELECT ON routine_analytics_view TO authenticated;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:13:43.796Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:11:03.050Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
CREATE VIEW routine_analytics_view AS
WITH routine_stats AS (
  SELECT
    user_id,
    COUNT(*) AS total_routines,
    COALESCE(SUM(total_duration), 0) AS total_minutes,
    COUNT(DISTINCT DATE(started_at)) AS days_tracked,
    MAX(DATE(started_at)) AS last_tracked_date
  FROM routine_executions
  GROUP BY user_id
),
step_stats AS (
  SELECT
    re.user_id,
    COUNT(*) FILTER (WHERE se.status = 'completed') AS total_steps,
    COALESCE(SUM(COALESCE(se.actual_duration, 0)), 0) AS total_step_minutes
  FROM step_executions se
  INNER JOIN routine_executions re ON re.id = se.routine_execution_id
  GROUP BY re.user_id
)
SELECT
  rs.user_id,
  rs.total_routines,
  COALESCE(ss.total_steps, 0) AS total_steps,
  rs.total_minutes,
  COALESCE(ss.total_step_minutes, 0) AS total_step_minutes,
  rs.days_tracked,
  rs.last_tracked_date
FROM routine_stats rs
LEFT JOIN step_stats ss ON ss.user_id = rs.user_id;

-- Grant usage via existing RLS policies on the underlying tables
GRANT SELECT ON routine_analytics_view TO authenticated;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:02:55.908Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T23:01:56.373Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$$;

      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$$;

      -- User Settings Policies
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';

      -- Triggers for updated_at
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $$ language 'plpgsql' SECURITY DEFINER;

      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- Add actual_duration if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $$;
;
-- Add buffer_time if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $$;
;
-- Add completed_at if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $$;
;
-- Add is_public if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- Ensure task_templates estimated_duration is positive
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:52:09.508Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_1$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_1$;

      DO $anon_2$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_2$;

      DO $anon_3$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_3$;

      -- User Settings Policies
      DO $anon_4$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_4$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_5$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_5$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_6$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_5$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_6$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_7$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_7$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_8$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_7$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_8$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_9$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_9$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_10$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_10$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_11$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_11$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_12$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_12$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_13$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_13$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_14$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_14$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_15$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_15$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_16$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_16$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_17$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_17$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_18$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_18$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_19$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_19$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_20$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_20$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_21$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_21$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_22$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_22$;
;
-- Add actual_duration if it doesn't exist
DO $anon_23$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_23$;
;
-- Add buffer_time if it doesn't exist
DO $anon_24$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_24$;
;
-- Add completed_at if it doesn't exist
DO $anon_25$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_25$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_26$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_26$;
;
-- Add is_public if it doesn't exist
DO $anon_27$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_27$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_28$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_28$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_29$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_29$;

-- Ensure task_templates estimated_duration is positive
DO $anon_30$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_30$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_31$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_31$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:51:10.671Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_32$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_32$;

      DO $anon_33$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_33$;

      DO $anon_34$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_34$;

      -- User Settings Policies
      DO $anon_35$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_35$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_36$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_36$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_37$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_36$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_37$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_38$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_38$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_39$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_38$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_39$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_40$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_40$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_41$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_41$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_42$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_42$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_43$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_43$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_44$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_44$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_45$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_45$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_46$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_46$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_47$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_47$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_48$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_48$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_49$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_49$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_50$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_50$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_51$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_51$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_52$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_52$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_53$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_53$;
;
-- Add actual_duration if it doesn't exist
DO $anon_54$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_54$;
;
-- Add buffer_time if it doesn't exist
DO $anon_55$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_55$;
;
-- Add completed_at if it doesn't exist
DO $anon_56$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_56$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_57$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_57$;
;
-- Add is_public if it doesn't exist
DO $anon_58$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_58$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_59$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_59$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_60$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_60$;

-- Ensure task_templates estimated_duration is positive
DO $anon_61$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_61$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_62$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_62$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:49:37.361Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_63$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_63$;

      DO $anon_64$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_64$;

      DO $anon_65$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_65$;

      -- User Settings Policies
      DO $anon_66$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_66$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_67$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_67$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_68$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_67$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_68$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_69$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_69$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_70$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_69$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_70$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_71$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_71$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_72$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_72$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_73$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_73$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_74$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_74$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_75$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_75$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_76$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_76$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_77$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_77$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_78$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_78$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_79$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_79$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_80$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_80$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_81$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_81$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_82$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_82$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_83$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_83$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_84$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_84$;
;
-- Add actual_duration if it doesn't exist
DO $anon_85$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_85$;
;
-- Add buffer_time if it doesn't exist
DO $anon_86$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_86$;
;
-- Add completed_at if it doesn't exist
DO $anon_87$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_87$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_88$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_88$;
;
-- Add is_public if it doesn't exist
DO $anon_89$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_89$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_90$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_90$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_91$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_91$;

-- Ensure task_templates estimated_duration is positive
DO $anon_92$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_92$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_93$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_93$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
CREATE VIEW routine_analytics_view AS
WITH routine_stats AS (
  SELECT
    user_id,
    COUNT(*) AS total_routines,
    COALESCE(SUM(total_duration), 0) AS total_minutes,
    COUNT(DISTINCT DATE(started_at)) AS days_tracked,
    MAX(DATE(started_at)) AS last_tracked_date
  FROM routine_executions
  GROUP BY user_id
),
step_stats AS (
  SELECT
    re.user_id,
    COUNT(*) FILTER (WHERE se.status = 'completed') AS total_steps,
    COALESCE(SUM(COALESCE(se.actual_duration, 0)), 0) AS total_step_minutes
  FROM step_executions se
  INNER JOIN routine_executions re ON re.id = se.routine_execution_id
  GROUP BY re.user_id
)
SELECT
  rs.user_id,
  rs.total_routines,
  COALESCE(ss.total_steps, 0) AS total_steps,
  rs.total_minutes,
  COALESCE(ss.total_step_minutes, 0) AS total_step_minutes,
  rs.days_tracked,
  rs.last_tracked_date
FROM routine_stats rs
LEFT JOIN step_stats ss ON ss.user_id = rs.user_id;

-- Grant usage via existing RLS policies on the underlying tables
GRANT SELECT ON routine_analytics_view TO authenticated;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:33:23.088Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_94$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_94$;

      DO $anon_95$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_95$;

      DO $anon_96$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_96$;

      -- User Settings Policies
      DO $anon_97$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_97$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_98$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_98$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_99$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_98$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_99$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_100$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_100$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_101$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_100$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_101$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_102$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_102$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_103$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_103$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_104$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_104$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_105$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_105$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_106$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_106$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_107$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_107$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_108$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
    -- (duplicate demo-user block removed)
    ;
-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_108$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_108$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_109$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_109$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_110$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_111$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_111$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_112$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_112$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_113$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_113$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_113$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_114$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_115$;
;
-- Add actual_duration if it doesn't exist
DO $anon_115$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_116$;
;
-- Add buffer_time if it doesn't exist
DO $anon_116$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_117$;
;
-- Add completed_at if it doesn't exist
DO $anon_117$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_118$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_118$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_119$;
;
-- Add is_public if it doesn't exist
DO $anon_119$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_120$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_120$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_121$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_121$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_122$;

-- Ensure task_templates estimated_duration is positive
DO $anon_122$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_123$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_123$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_124$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:32:44.050Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_124$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_125$;

      DO $anon_125$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_126$;

      DO $anon_126$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_127$;

      -- User Settings Policies
      DO $anon_127$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_128$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_128$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_129$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_129$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_128$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_130$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_130$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_131$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_131$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_130$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_132$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_132$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_133$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_133$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_134$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_134$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_134$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_135$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_135$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_136$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_136$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_137$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_137$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_138$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_138$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_139$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_139$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_140$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_140$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_141$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_142$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_142$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_143$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_143$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_144$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_144$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_144$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_145$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_146$;
;
-- Add actual_duration if it doesn't exist
DO $anon_146$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_147$;
;
-- Add buffer_time if it doesn't exist
DO $anon_147$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_148$;
;
-- Add completed_at if it doesn't exist
DO $anon_148$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_149$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_149$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_150$;
;
-- Add is_public if it doesn't exist
DO $anon_150$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_151$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_151$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_152$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_152$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_153$;

-- Ensure task_templates estimated_duration is positive
DO $anon_153$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_154$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_154$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_155$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:31:39.065Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_155$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_156$;

      DO $anon_156$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_157$;

      DO $anon_157$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_158$;

      -- User Settings Policies
      DO $anon_158$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_159$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_159$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_160$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_160$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_159$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_161$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_161$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_162$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_162$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_161$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_163$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_163$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_164$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_164$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_165$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_165$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_165$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_166$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_166$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_167$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_167$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_168$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_168$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_169$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_169$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_170$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_170$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_171$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_171$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_172$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_173$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_173$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_174$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_174$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_175$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_175$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_175$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_176$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_177$;
;
-- Add actual_duration if it doesn't exist
DO $anon_177$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_178$;
;
-- Add buffer_time if it doesn't exist
DO $anon_178$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_179$;
;
-- Add completed_at if it doesn't exist
DO $anon_179$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_180$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_180$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_181$;
;
-- Add is_public if it doesn't exist
DO $anon_181$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_182$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_182$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_183$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_183$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_184$;

-- Ensure task_templates estimated_duration is positive
DO $anon_184$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_185$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_185$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_186$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:30:53.578Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_186$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_187$;

      DO $anon_187$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_188$;

      DO $anon_188$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_189$;

      -- User Settings Policies
      DO $anon_189$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_190$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_190$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_191$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_191$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_190$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_192$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_192$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_193$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_193$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_192$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_194$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_194$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_195$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_195$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_196$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_196$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_196$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_197$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_197$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_198$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_198$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_199$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_199$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_200$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_200$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_201$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_201$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_202$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_202$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_203$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_204$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_204$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_205$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_205$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_206$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_206$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_206$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_207$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_208$;
;
-- Add actual_duration if it doesn't exist
DO $anon_208$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_209$;
;
-- Add buffer_time if it doesn't exist
DO $anon_209$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_210$;
;
-- Add completed_at if it doesn't exist
DO $anon_210$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_211$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_211$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_212$;
;
-- Add is_public if it doesn't exist
DO $anon_212$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_213$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_213$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_214$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_214$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_215$;

-- Ensure task_templates estimated_duration is positive
DO $anon_215$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_216$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_216$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_217$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:29:59.591Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_217$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_218$;

      DO $anon_218$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_219$;

      DO $anon_219$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_220$;

      -- User Settings Policies
      DO $anon_220$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_221$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_221$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_222$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_222$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_221$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_223$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_223$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_224$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_224$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_223$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_225$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

-- Routine Executions Policies
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

-- Step Executions Policies
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Interruptions Policies
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

-- Routine Templates Policies
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

-- Template Steps Policies
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_225$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_226$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_226$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_227$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_227$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_227$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_228$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_228$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_229$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_229$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_230$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_230$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_231$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_231$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_232$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_232$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_233$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_233$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_234$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_235$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_235$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_236$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_236$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_237$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_237$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_237$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_238$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_239$;
;
-- Add actual_duration if it doesn't exist
DO $anon_239$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
END $anon_240$;
;
-- Add buffer_time if it doesn't exist
DO $anon_240$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_241$;
;
-- Add completed_at if it doesn't exist
DO $anon_241$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_242$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_242$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_243$;
;
-- Add is_public if it doesn't exist
DO $anon_243$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_244$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_244$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_245$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_245$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_246$;

-- Ensure task_templates estimated_duration is positive
DO $anon_246$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_247$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_247$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_248$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Generated all-migrations gap-fix
-- Generated at 2025-11-20T21:18:25.159Z

-- Backup of `001_initial_schema.sql` (disabled to allow pushing remaining migrations)
-- This file was copied from the original and renamed to avoid re-applying a partially-corrupted initial migration.

-- (original content preserved here as a backup; not executed by Supabase CLI because filename doesn't match timestamped pattern)
;
;
-- Disabled initial schema migration.
-- The original migration was partially corrupted; a full backup is stored in
-- `supabase/migrations/001_initial_schema.disabled.sql`.
-- This file is intentionally empty so the Supabase CLI will skip re-running
-- the heavy initial schema. Remaining delta migrations (metrics, views, etc.)
-- will be applied by `db push`.

      -- Tasks Table
      CREATE TABLE IF NOT EXISTS tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        category task_category NOT NULL,
        priority priority DEFAULT 'medium',
        estimated_duration INTEGER NOT NULL, -- minutes
        actual_duration INTEGER,
        buffer_time INTEGER DEFAULT 0,
        status task_status DEFAULT 'not-started',
        due_date TIMESTAMPTZ,
        scheduled_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        tags TEXT[] DEFAULT '{}',
        energy_required energy_level DEFAULT 'medium',
        focus_required focus_level DEFAULT 'medium',
        sensory_considerations JSONB DEFAULT '[]',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routines Table
      CREATE TABLE IF NOT EXISTS routines (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        name TEXT NOT NULL,
        description TEXT,
        type routine_type NOT NULL,
        is_active BOOLEAN DEFAULT true,
        is_template BOOLEAN DEFAULT false,
        flexibility flexibility_level DEFAULT 'flexible',
        schedule JSONB NOT NULL, -- frequency, days, times, etc.
        adaptive_rules JSONB DEFAULT '[]',
        visual_board JSONB, -- board configuration
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Routine Tasks Junction Table
      CREATE TABLE IF NOT EXISTS routine_tasks (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
        task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        order_index INTEGER NOT NULL,
        is_optional BOOLEAN DEFAULT false,
        estimated_duration INTEGER NOT NULL,
        buffer_time INTEGER DEFAULT 0,
        conditions JSONB, -- conditional execution rules
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(routine_id, task_id)
      );

      -- Mood Entries Table
      CREATE TABLE IF NOT EXISTS mood_entries (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        timestamp TIMESTAMPTZ NOT NULL,
        mood INTEGER NOT NULL CHECK (mood >= 1 AND mood <= 10),
        energy INTEGER NOT NULL CHECK (energy >= 1 AND energy <= 10),
        focus INTEGER NOT NULL CHECK (focus >= 1 AND focus <= 10),
        anxiety INTEGER NOT NULL CHECK (anxiety >= 1 AND anxiety <= 10),
        stress INTEGER NOT NULL CHECK (stress >= 1 AND stress <= 10),
        motivation INTEGER NOT NULL CHECK (motivation >= 1 AND motivation <= 10),
        notes TEXT,
        triggers TEXT[],
        context JSONB, -- location, weather, sleep, etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- AI Insights Table
      CREATE TABLE IF NOT EXISTS ai_insights (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type insight_type NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
        relevance DECIMAL(3,2) CHECK (relevance >= 0 AND relevance <= 1),
        actionable BOOLEAN DEFAULT false,
        suggestions JSONB DEFAULT '[]',
        data JSONB DEFAULT '{}', -- raw analysis data
        generated_at TIMESTAMPTZ DEFAULT NOW(),
        dismissed_at TIMESTAMPTZ
      );

      -- Shared Boards Table (for collaboration)
      CREATE TABLE IF NOT EXISTS shared_boards (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        board_id UUID NOT NULL, -- references routine or custom board
        owner_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        shared_with JSONB NOT NULL, -- array of access objects
        permissions JSONB NOT NULL,
        is_public BOOLEAN DEFAULT false,
        share_code TEXT UNIQUE,
        expires_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- Notifications Table
      CREATE TABLE IF NOT EXISTS notifications (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        message TEXT NOT NULL,
        type notification_type NOT NULL,
        priority priority DEFAULT 'medium',
        actionable BOOLEAN DEFAULT false,
        actions JSONB, -- available actions
        scheduled_for TIMESTAMPTZ,
        delivered_at TIMESTAMPTZ,
        read_at TIMESTAMPTZ,
        dismissed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- App Events Table (for analytics and AI training)
      CREATE TABLE IF NOT EXISTS app_events (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
        type event_type NOT NULL,
        source event_source NOT NULL,
        data JSONB DEFAULT '{}',
        timestamp TIMESTAMPTZ DEFAULT NOW()
      );

      -- Quick Captures Table (for AI recall feature)
      CREATE TABLE IF NOT EXISTS quick_captures (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('voice_note', 'photo', 'free_write', 'sketch')),
        title TEXT,
        content TEXT,
        file_url TEXT, -- for photos/audio files
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
      );

      -- User Activity Tracking (for AI recall)
      CREATE TABLE IF NOT EXISTS user_activity (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
        activity_type TEXT NOT NULL CHECK (activity_type IN ('task_work', 'routine_execution', 'quick_capture', 'dashboard_view')),
        entity_id UUID, -- references task, routine, or capture
        entity_type TEXT CHECK (entity_type IN ('task', 'routine', 'quick_capture')),
        duration_minutes INTEGER,
        context JSONB DEFAULT '{}',
        started_at TIMESTAMPTZ DEFAULT NOW(),
        ended_at TIMESTAMPTZ
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
      CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
      CREATE INDEX IF NOT EXISTS idx_tasks_category ON tasks(category);

      CREATE INDEX IF NOT EXISTS idx_routines_user_id ON routines(user_id);
      CREATE INDEX IF NOT EXISTS idx_routines_type ON routines(type);
      CREATE INDEX IF NOT EXISTS idx_routines_active ON routines(is_active);

      CREATE INDEX IF NOT EXISTS idx_routine_tasks_routine_id ON routine_tasks(routine_id);
      CREATE INDEX IF NOT EXISTS idx_routine_tasks_order ON routine_tasks(order_index);

      CREATE INDEX IF NOT EXISTS idx_mood_entries_user_id ON mood_entries(user_id);
      CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON mood_entries(timestamp);

      CREATE INDEX IF NOT EXISTS idx_ai_insights_user_id ON ai_insights(user_id);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_type ON ai_insights(type);
      CREATE INDEX IF NOT EXISTS idx_ai_insights_dismissed ON ai_insights(dismissed_at);

      CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
      CREATE INDEX IF NOT EXISTS idx_notifications_delivered ON notifications(delivered_at);
      CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read_at);

      CREATE INDEX IF NOT EXISTS idx_app_events_user_id ON app_events(user_id);
      CREATE INDEX IF NOT EXISTS idx_app_events_type ON app_events(type);
      CREATE INDEX IF NOT EXISTS idx_app_events_timestamp ON app_events(timestamp);

      -- Row Level Security Policies
      ALTER TABLE IF EXISTS user_profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_settings ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routines ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS routine_tasks ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS mood_entries ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS ai_insights ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS shared_boards ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS app_events ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS quick_captures ENABLE ROW LEVEL SECURITY;
      ALTER TABLE IF EXISTS user_activity ENABLE ROW LEVEL SECURITY;

      -- User Profiles Policies
      DO $anon_248$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_view_own_profile'
        ) THEN
          CREATE POLICY "Users can view own profile" ON public.user_profiles
            FOR SELECT USING (auth.uid() = id);
        END IF;
      END$anon_249$;

      DO $anon_249$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_update_own_profile'
        ) THEN
          CREATE POLICY "Users can update own profile" ON public.user_profiles
            FOR UPDATE USING (auth.uid() = id);
        END IF;
      END$anon_250$;

      DO $anon_250$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_profiles' AND p.polname = 'users_can_insert_own_profile'
        ) THEN
          CREATE POLICY "Users can insert own profile" ON public.user_profiles
            FOR INSERT WITH CHECK (auth.uid() = id);
        END IF;
      END$anon_251$;

      -- User Settings Policies
      DO $anon_251$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_catalog.pg_policy p
          JOIN pg_class c ON p.polrelid = c.oid
          WHERE c.relname = 'user_settings' AND p.polname = 'users_can_manage_own_settings'
        ) THEN
          CREATE POLICY "Users can manage own settings" ON user_settings
            FOR ALL USING (auth.uid() = user_id);
        END IF;
      END$anon_252$;

      -- Functions
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $anon_252$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $anon_253$ language 'plpgsql';

      -- Triggers for updated_at
      DO $anon_253$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profiles_updated_at') THEN
  RETURN NEW;
END;
$anon_252$ LANGUAGE plpgsql;
          CREATE TRIGGER update_user_profiles_updated_at 
            BEFORE UPDATE ON user_profiles 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tasks_updated_at') THEN
          CREATE TRIGGER update_tasks_updated_at 
            BEFORE UPDATE ON tasks 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_routines_updated_at') THEN
          CREATE TRIGGER update_routines_updated_at 
            BEFORE UPDATE ON routines 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        END IF;
      END$anon_254$;

      -- Function to handle user profile creation
      CREATE OR REPLACE FUNCTION handle_new_user()
      RETURNS TRIGGER AS $anon_254$
      BEGIN
        INSERT INTO user_profiles (id, email, display_name, neurotype, age_group)
        VALUES (
          NEW.id,
          NEW.email,
          COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
          COALESCE(NEW.raw_user_meta_data->>'neurotype', 'exploring')::neurotype,
          COALESCE(NEW.raw_user_meta_data->>'age_group', 'adult')::age_group
        );
        RETURN NEW;
      END;
      $anon_255$ language 'plpgsql' SECURITY DEFINER;

      DO $anon_255$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
  RETURN NEW;
END;
$anon_254$ LANGUAGE plpgsql;
          CREATE TRIGGER on_auth_user_created
            AFTER INSERT ON auth.users
            FOR EACH ROW EXECUTE FUNCTION handle_new_user();
        END IF;
      END$anon_256$;
;
-- Enhanced Routine Steps Migration for Flex Zones & Transition Support
-- This migration adds comprehensive support for flex zones, transitions, and freeform content

-- Create new enums for enhanced routine functionality
CREATE TYPE routine_step_type AS ENUM ('routine', 'flexZone', 'note');
CREATE TYPE transition_cue_type AS ENUM ('text', 'audio', 'visual', 'mixed');
CREATE TYPE freeform_data_type AS ENUM ('note', 'sketch');
CREATE TYPE step_execution_status AS ENUM ('pending', 'active', 'paused', 'completed', 'skipped');
CREATE TYPE timer_notification_type AS ENUM ('visual', 'audio', 'vibration', 'all');
CREATE TYPE timer_intensity AS ENUM ('subtle', 'normal', 'prominent');
CREATE TYPE neurotype_time_awareness AS ENUM ('high', 'medium', 'low');
CREATE TYPE autism_routine_rigidity AS ENUM ('flexible', 'structured', 'strict');

-- Enhanced Routine Steps Table
CREATE TABLE routine_steps (
  step_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0, -- minutes
  order_index INTEGER NOT NULL,
  
  -- Transition Support Properties
  transition_cue JSONB, -- TransitionCue object
  
  -- Flex Zone Specific Properties
  freeform_data JSONB, -- FreeformData object
  timer_settings JSONB, -- TimerSettings object
  is_flexible BOOLEAN DEFAULT false,
  
  -- Visual and Accessibility Support
  visual_cues JSONB, -- color, icon, emoji, backgroundColor, borderColor
  
  -- Neurotype Adaptations
  neurotype_adaptations JSONB, -- ADHD, autism, dyslexia specific settings
  
  -- Execution State (runtime)
  execution_state JSONB, -- status, startedAt, completedAt, actualDuration, notes
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  version INTEGER DEFAULT 1
);

-- Routine Executions Table
CREATE TABLE routine_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_id UUID NOT NULL REFERENCES routines(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
  
  -- Execution tracking
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  current_step_id UUID REFERENCES routine_steps(step_id),
  total_duration INTEGER, -- actual minutes taken
  
  -- Flexibility tracking
  modifications JSONB DEFAULT '[]', -- RoutineModification array
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Step Executions Table
CREATE TABLE step_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  step_id UUID NOT NULL REFERENCES routine_steps(step_id) ON DELETE CASCADE,
  
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  actual_duration INTEGER, -- minutes
  status step_execution_status DEFAULT 'pending',
  
  -- Flex zone specific
  freeform_data_snapshot JSONB, -- Snapshot of freeform content
  timer_overrun INTEGER DEFAULT 0, -- minutes past planned duration
  
  -- User feedback
  difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
  satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
  notes TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Interruptions Table
CREATE TABLE routine_interruptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  routine_execution_id UUID NOT NULL REFERENCES routine_executions(id) ON DELETE CASCADE,
  interruption_type TEXT NOT NULL CHECK (interruption_type IN ('external', 'internal', 'planned')),
  description TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  impact TEXT NOT NULL CHECK (impact IN ('minor', 'moderate', 'major')),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Routine Templates Table
CREATE TABLE routine_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'custom')),
  estimated_duration INTEGER NOT NULL,
  
  -- Template metadata
  is_public BOOLEAN DEFAULT false,
  author_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  neurotype_optimized TEXT[] DEFAULT '{}', -- ['adhd', 'autism', 'dyslexia']
  
  -- Usage statistics
  usage_count INTEGER DEFAULT 0,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template Steps Table
CREATE TABLE template_steps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID NOT NULL REFERENCES routine_templates(id) ON DELETE CASCADE,
  step_type routine_step_type NOT NULL DEFAULT 'routine',
  title TEXT NOT NULL,
  description TEXT,
  duration INTEGER NOT NULL DEFAULT 0,
  order_index INTEGER NOT NULL,
  
  -- All the same properties as routine_steps but without routine_id
  transition_cue JSONB,
  freeform_data JSONB,
  timer_settings JSONB,
  is_flexible BOOLEAN DEFAULT false,
  visual_cues JSONB,
  neurotype_adaptations JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_routine_steps_routine_id ON routine_steps(routine_id);
CREATE INDEX idx_routine_steps_order ON routine_steps(order_index);
CREATE INDEX idx_routine_steps_type ON routine_steps(step_type);

CREATE INDEX idx_routine_executions_user_id ON routine_executions(user_id);
CREATE INDEX idx_routine_executions_routine_id ON routine_executions(routine_id);
CREATE INDEX idx_routine_executions_started_at ON routine_executions(started_at);

CREATE INDEX idx_step_executions_routine_execution_id ON step_executions(routine_execution_id);
CREATE INDEX idx_step_executions_step_id ON step_executions(step_id);
CREATE INDEX idx_step_executions_status ON step_executions(status);

CREATE INDEX idx_routine_interruptions_routine_execution_id ON routine_interruptions(routine_execution_id);

CREATE INDEX idx_routine_templates_category ON routine_templates(category);
CREATE INDEX idx_routine_templates_public ON routine_templates(is_public);
CREATE INDEX idx_routine_templates_author_id ON routine_templates(author_id);

CREATE INDEX idx_template_steps_template_id ON template_steps(template_id);
CREATE INDEX idx_template_steps_order ON template_steps(order_index);

-- Row Level Security
ALTER TABLE routine_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_interruptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_steps ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Routine Steps Policies
DROP POLICY IF EXISTS "Users can manage routine steps" ON routine_steps;
CREATE POLICY "Users can manage routine steps" ON routine_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routines 
      WHERE routines.id = routine_steps.routine_id 
      AND routines.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Users can manage own routine executions" ON routine_executions;
CREATE POLICY "Users can manage own routine executions" ON routine_executions
  FOR ALL USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can manage step executions" ON step_executions;
CREATE POLICY "Users can manage step executions" ON step_executions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = step_executions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Users can manage routine interruptions" ON routine_interruptions;
CREATE POLICY "Users can manage routine interruptions" ON routine_interruptions
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_executions 
      WHERE routine_executions.id = routine_interruptions.routine_execution_id 
      AND routine_executions.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Users can view public templates" ON routine_templates;
CREATE POLICY "Users can view public templates" ON routine_templates
  FOR SELECT USING (is_public = true OR author_id = auth.uid());

DROP POLICY IF EXISTS "Users can manage own templates" ON routine_templates;
CREATE POLICY "Users can manage own templates" ON routine_templates
  FOR ALL USING (auth.uid() = author_id);

DROP POLICY IF EXISTS "Users can create templates" ON routine_templates;
CREATE POLICY "Users can create templates" ON routine_templates
  FOR INSERT WITH CHECK (auth.uid() = author_id);

DROP POLICY IF EXISTS "Users can view template steps" ON template_steps;
CREATE POLICY "Users can view template steps" ON template_steps
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND (routine_templates.is_public = true OR routine_templates.author_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "Users can manage own template steps" ON template_steps;
CREATE POLICY "Users can manage own template steps" ON template_steps
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM routine_templates 
      WHERE routine_templates.id = template_steps.template_id 
      AND routine_templates.author_id = auth.uid()
    )
  );

-- Update triggers for updated_at
CREATE TRIGGER update_routine_steps_updated_at 
  BEFORE UPDATE ON routine_steps 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_executions_updated_at 
  BEFORE UPDATE ON routine_executions 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_routine_templates_updated_at 
  BEFORE UPDATE ON routine_templates 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Helper functions

-- Function to calculate total routine duration
CREATE OR REPLACE FUNCTION calculate_routine_duration(routine_id_param UUID)
RETURNS INTEGER AS $anon_256$
DECLARE
  total_duration INTEGER := 0;
BEGIN
  SELECT COALESCE(SUM(duration), 0) INTO total_duration
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN total_duration;
END;
$anon_257$ LANGUAGE plpgsql;

-- Function to get next step order index
CREATE OR REPLACE FUNCTION get_next_step_order(routine_id_param UUID)
RETURNS INTEGER AS $anon_257$
DECLARE
  next_order INTEGER := 1;
BEGIN
  SELECT COALESCE(MAX(order_index), 0) + 1 INTO next_order
  FROM routine_steps
  WHERE routine_id = routine_id_param;
  
  RETURN next_order;
END;
$anon_258$ LANGUAGE plpgsql;

-- Function to reorder steps after deletion
CREATE OR REPLACE FUNCTION reorder_routine_steps()
RETURNS TRIGGER AS $anon_258$
BEGIN
  UPDATE routine_steps 
  SET order_index = order_index - 1
  WHERE routine_id = OLD.routine_id 
  AND order_index > OLD.order_index;
  
  RETURN OLD;
END;
  RETURN NEW;
$anon_258$ LANGUAGE plpgsql;

-- Trigger to maintain step order
CREATE TRIGGER reorder_steps_after_delete
  AFTER DELETE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION reorder_routine_steps();

-- Function to validate routine step constraints
CREATE OR REPLACE FUNCTION validate_routine_constraints()
RETURNS TRIGGER AS $anon_259$
BEGIN
  -- Prevent consecutive flex zones (business rule example)
  IF NEW.step_type = 'flexZone' THEN
    -- Check if previous step is also a flex zone
    IF EXISTS (
      SELECT 1 FROM routine_steps 
      WHERE routine_id = NEW.routine_id 
      AND order_index = NEW.order_index - 1 
      AND step_type = 'flexZone'
    ) THEN
      RAISE EXCEPTION 'Cannot have consecutive flex zones in routine';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$anon_259$ LANGUAGE plpgsql;

-- Trigger for constraint validation
CREATE TRIGGER validate_routine_step_constraints
  BEFORE INSERT OR UPDATE ON routine_steps
  FOR EACH ROW
  EXECUTE FUNCTION validate_routine_constraints();

-- Add comments for documentation
COMMENT ON TABLE routine_steps IS 'Enhanced routine steps supporting flex zones and transitions';
COMMENT ON TABLE routine_executions IS 'Tracks individual routine execution sessions';
COMMENT ON TABLE step_executions IS 'Tracks execution of individual routine steps';
COMMENT ON TABLE routine_interruptions IS 'Records interruptions during routine execution';
COMMENT ON TABLE routine_templates IS 'Reusable routine templates with community sharing';
COMMENT ON TABLE template_steps IS 'Steps belonging to routine templates';

COMMENT ON COLUMN routine_steps.transition_cue IS 'JSON object containing transition cue settings (text, audio, visual)';
COMMENT ON COLUMN routine_steps.freeform_data IS 'JSON object for free write/sketch content in flex zones';
COMMENT ON COLUMN routine_steps.timer_settings IS 'JSON object for timer configuration and notifications';
COMMENT ON COLUMN routine_steps.neurotype_adaptations IS 'JSON object with ADHD, autism, dyslexia specific adaptations';
;
-- Migration: Add tables for new features (Pomodoro, Habits, Focus, Energy, Body Doubling)
-- Created: 2025-11-07

-- =============================================
-- POMODORO SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.pomodoro_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    preset_id TEXT NOT NULL,
    preset_name TEXT NOT NULL,
    work_duration INTEGER NOT NULL, -- in seconds
    break_duration INTEGER NOT NULL,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    phase TEXT NOT NULL CHECK (phase IN ('work', 'break', 'long-break')),
    completed BOOLEAN NOT NULL DEFAULT false,
    interruptions INTEGER DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.pomodoro_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own pomodoro sessions"
    ON public.pomodoro_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pomodoro sessions"
    ON public.pomodoro_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pomodoro sessions"
    ON public.pomodoro_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_pomodoro_sessions_user_id ON public.pomodoro_sessions(user_id);
CREATE INDEX idx_pomodoro_sessions_started_at ON public.pomodoro_sessions(started_at);

-- =============================================
-- HABITS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    category TEXT NOT NULL CHECK (category IN ('health', 'productivity', 'self-care', 'social', 'learning', 'creative')),
    frequency TEXT NOT NULL CHECK (frequency IN ('daily', 'weekly', 'custom')),
    target_days INTEGER[] DEFAULT ARRAY[0,1,2,3,4,5,6], -- 0=Sunday, 6=Saturday
    reminder_time TIME,
    reminder_enabled BOOLEAN DEFAULT false,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    archived BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habits"
    ON public.habits FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habits"
    ON public.habits FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own habits"
    ON public.habits FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own habits"
    ON public.habits FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habits_user_id ON public.habits(user_id);
CREATE INDEX idx_habits_category ON public.habits(category);

-- =============================================
-- HABIT LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    completed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    notes TEXT,
    mood TEXT CHECK (mood IN ('great', 'good', 'okay', 'struggling', 'difficult')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit logs"
    ON public.habit_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit logs"
    ON public.habit_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit logs"
    ON public.habit_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_logs_habit_id ON public.habit_logs(habit_id);
CREATE INDEX idx_habit_logs_user_id ON public.habit_logs(user_id);
CREATE INDEX idx_habit_logs_completed_at ON public.habit_logs(completed_at);

-- =============================================
-- HABIT STACKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.habit_stacks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    trigger_habit_id UUID REFERENCES public.habits(id) ON DELETE CASCADE,
    new_habit_id UUID NOT NULL REFERENCES public.habits(id) ON DELETE CASCADE,
    trigger_description TEXT NOT NULL,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.habit_stacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own habit stacks"
    ON public.habit_stacks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own habit stacks"
    ON public.habit_stacks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own habit stacks"
    ON public.habit_stacks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_habit_stacks_user_id ON public.habit_stacks(user_id);

-- =============================================
-- FOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    task_name TEXT,
    duration INTEGER NOT NULL, -- in seconds
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    distraction_count INTEGER DEFAULT 0,
    ambient_sound TEXT,
    blocked_sites TEXT[],
    completed BOOLEAN DEFAULT false,
    focus_score INTEGER CHECK (focus_score >= 0 AND focus_score <= 100),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own focus sessions"
    ON public.focus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own focus sessions"
    ON public.focus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own focus sessions"
    ON public.focus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_focus_sessions_user_id ON public.focus_sessions(user_id);
CREATE INDEX idx_focus_sessions_start_time ON public.focus_sessions(start_time);

-- =============================================
-- ENERGY LOGS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.energy_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 5),
    mood TEXT,
    physical_energy INTEGER CHECK (physical_energy >= 1 AND physical_energy <= 5),
    mental_energy INTEGER CHECK (mental_energy >= 1 AND mental_energy <= 5),
    factors TEXT[], -- e.g., ['slept_well', 'exercised', 'caffeine']
    notes TEXT,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.energy_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own energy logs"
    ON public.energy_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own energy logs"
    ON public.energy_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own energy logs"
    ON public.energy_logs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own energy logs"
    ON public.energy_logs FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_energy_logs_user_id ON public.energy_logs(user_id);
CREATE INDEX idx_energy_logs_logged_at ON public.energy_logs(logged_at);

-- =============================================
-- BODY DOUBLING ROOMS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.body_doubling_rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    room_type TEXT NOT NULL CHECK (room_type IN ('video', 'silent', 'audio-only')),
    created_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    is_public BOOLEAN DEFAULT true,
    max_participants INTEGER DEFAULT 10,
    current_participants INTEGER DEFAULT 0,
    tags TEXT[],
    scheduled_start TIMESTAMPTZ,
    scheduled_end TIMESTAMPTZ,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'scheduled', 'ended')),
    webrtc_room_id TEXT UNIQUE, -- For WebRTC integration
    external_service_id TEXT, -- For integration with external body doubling services
    external_service_name TEXT, -- e.g., 'focusmate', 'study-together', 'flow-club'
    webhook_url TEXT, -- Webhook URL for external service integration
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.body_doubling_rooms ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view public rooms"
    ON public.body_doubling_rooms FOR SELECT
    USING (is_public = true OR auth.uid() = created_by);

CREATE POLICY "Authenticated users can create rooms"
    ON public.body_doubling_rooms FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Room creators can update their rooms"
    ON public.body_doubling_rooms FOR UPDATE
    USING (auth.uid() = created_by);

CREATE POLICY "Room creators can delete their rooms"
    ON public.body_doubling_rooms FOR DELETE
    USING (auth.uid() = created_by);

-- Add indexes
CREATE INDEX idx_body_doubling_rooms_created_by ON public.body_doubling_rooms(created_by);
CREATE INDEX idx_body_doubling_rooms_status ON public.body_doubling_rooms(status);
CREATE INDEX idx_body_doubling_rooms_external_service ON public.body_doubling_rooms(external_service_id);

-- =============================================
-- ROOM PARTICIPANTS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.room_participants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES public.body_doubling_rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    left_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,
    camera_enabled BOOLEAN DEFAULT false,
    microphone_enabled BOOLEAN DEFAULT false,
    peer_id TEXT, -- For WebRTC peer connection
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(room_id, user_id)
);

-- Add RLS policies
ALTER TABLE public.room_participants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view participants in their rooms"
    ON public.room_participants FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.body_doubling_rooms
            WHERE id = room_id AND (is_public = true OR created_by = auth.uid())
        )
    );

CREATE POLICY "Users can join rooms"
    ON public.room_participants FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own participation"
    ON public.room_participants FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can leave rooms"
    ON public.room_participants FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_room_participants_room_id ON public.room_participants(room_id);
CREATE INDEX idx_room_participants_user_id ON public.room_participants(user_id);

-- =============================================
-- TASK CHUNKS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.task_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    original_task TEXT NOT NULL,
    chunks JSONB NOT NULL, -- Array of {title, description, estimatedTime, difficulty, completed, order}
    completed_chunks INTEGER DEFAULT 0,
    total_chunks INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.task_chunks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own task chunks"
    ON public.task_chunks FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own task chunks"
    ON public.task_chunks FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own task chunks"
    ON public.task_chunks FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own task chunks"
    ON public.task_chunks FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_task_chunks_user_id ON public.task_chunks(user_id);

-- =============================================
-- HYPERFOCUS SESSIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.hyperfocus_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    break_reminders_sent INTEGER DEFAULT 0,
    hydration_reminders_sent INTEGER DEFAULT 0,
    movement_reminders_sent INTEGER DEFAULT 0,
    reminders_acknowledged INTEGER DEFAULT 0,
    reminders_snoozed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.hyperfocus_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own hyperfocus sessions"
    ON public.hyperfocus_sessions FOR UPDATE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_hyperfocus_sessions_user_id ON public.hyperfocus_sessions(user_id);
CREATE INDEX idx_hyperfocus_sessions_start_time ON public.hyperfocus_sessions(start_time);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_260$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_260$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_pomodoro_sessions_updated_at
    BEFORE UPDATE ON public.pomodoro_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_habits_updated_at
    BEFORE UPDATE ON public.habits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_focus_sessions_updated_at
    BEFORE UPDATE ON public.focus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_energy_logs_updated_at
    BEFORE UPDATE ON public.energy_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_body_doubling_rooms_updated_at
    BEFORE UPDATE ON public.body_doubling_rooms
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_chunks_updated_at
    BEFORE UPDATE ON public.task_chunks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hyperfocus_sessions_updated_at
    BEFORE UPDATE ON public.hyperfocus_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to update room participant count
CREATE OR REPLACE FUNCTION update_room_participant_count()
RETURNS TRIGGER AS $anon_261$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = current_participants + 1
        WHERE id = NEW.room_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.body_doubling_rooms
        SET current_participants = GREATEST(0, current_participants - 1)
        WHERE id = OLD.room_id;
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.is_active = false AND OLD.is_active = true THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = GREATEST(0, current_participants - 1)
            WHERE id = NEW.room_id;
        ELSIF NEW.is_active = true AND OLD.is_active = false THEN
            UPDATE public.body_doubling_rooms
            SET current_participants = current_participants + 1
            WHERE id = NEW.room_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$anon_261$ LANGUAGE plpgsql;

-- Add trigger for room participant count
CREATE TRIGGER update_room_participant_count_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION update_room_participant_count();

-- Function to notify room updates via webhook
CREATE OR REPLACE FUNCTION notify_room_webhook()
RETURNS TRIGGER AS $anon_262$
DECLARE
    webhook TEXT;
BEGIN
    SELECT webhook_url INTO webhook
    FROM public.body_doubling_rooms
    WHERE id = NEW.room_id;

    IF webhook IS NOT NULL THEN
        -- This would be called by a Supabase Edge Function or external service
        -- Store webhook notification in a queue table
        INSERT INTO public.webhook_queue (
            webhook_url,
            payload,
            event_type
        ) VALUES (
            webhook,
            jsonb_build_object(
                'room_id', NEW.room_id,
                'user_id', NEW.user_id,
                'event', TG_OP,
                'timestamp', NOW()
            ),
            'room_participant_change'
        );
    END IF;
    
    RETURN NEW;
END;
$anon_262$ LANGUAGE plpgsql;

-- =============================================
-- WEBHOOK QUEUE TABLE (for async webhook processing)
-- =============================================
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_url TEXT NOT NULL,
    payload JSONB NOT NULL,
    event_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

-- Add index
CREATE INDEX idx_webhook_queue_status ON public.webhook_queue(status);
CREATE INDEX idx_webhook_queue_created_at ON public.webhook_queue(created_at);

-- Add trigger for webhook notifications
CREATE TRIGGER notify_room_webhook_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.room_participants
    FOR EACH ROW EXECUTE FUNCTION notify_room_webhook();

-- =============================================
-- ANALYTICS VIEWS
-- =============================================

-- View for habit completion rates
CREATE OR REPLACE VIEW habit_completion_stats AS
SELECT 
    h.id,
    h.user_id,
    h.name,
    h.category,
    h.current_streak,
    h.longest_streak,
    COUNT(hl.id) as total_completions,
    COUNT(DISTINCT DATE(hl.completed_at)) as unique_days_completed,
    MAX(hl.completed_at) as last_completed
FROM public.habits h
LEFT JOIN public.habit_logs hl ON h.id = hl.habit_id
WHERE h.archived = false
GROUP BY h.id, h.user_id, h.name, h.category, h.current_streak, h.longest_streak;

-- View for energy patterns
CREATE OR REPLACE VIEW energy_patterns AS
SELECT 
    user_id,
    EXTRACT(HOUR FROM logged_at) as hour_of_day,
    AVG(energy_level) as avg_energy_level,
    AVG(physical_energy) as avg_physical_energy,
    AVG(mental_energy) as avg_mental_energy,
    COUNT(*) as sample_count
FROM public.energy_logs
WHERE logged_at > NOW() - INTERVAL '30 days'
GROUP BY user_id, EXTRACT(HOUR FROM logged_at);

-- View for focus session stats
CREATE OR REPLACE VIEW focus_session_stats AS
SELECT 
    user_id,
    COUNT(*) as total_sessions,
    SUM(duration) as total_focus_time_seconds,
    AVG(duration) as avg_session_duration,
    AVG(distraction_count) as avg_distractions,
    AVG(focus_score) as avg_focus_score,
    COUNT(*) FILTER (WHERE completed = true) as completed_sessions
FROM public.focus_sessions
WHERE start_time > NOW() - INTERVAL '30 days'
GROUP BY user_id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

-- Grant access to authenticated users
GRANT ALL ON public.pomodoro_sessions TO authenticated;
GRANT ALL ON public.habits TO authenticated;
GRANT ALL ON public.habit_logs TO authenticated;
GRANT ALL ON public.habit_stacks TO authenticated;
GRANT ALL ON public.focus_sessions TO authenticated;
GRANT ALL ON public.energy_logs TO authenticated;
GRANT ALL ON public.body_doubling_rooms TO authenticated;
GRANT ALL ON public.room_participants TO authenticated;
GRANT ALL ON public.task_chunks TO authenticated;
GRANT ALL ON public.hyperfocus_sessions TO authenticated;
GRANT ALL ON public.webhook_queue TO authenticated;

-- Grant read access to views
GRANT SELECT ON habit_completion_stats TO authenticated;
GRANT SELECT ON energy_patterns TO authenticated;
GRANT SELECT ON focus_session_stats TO authenticated;
;
-- Migration: Visual Boards System
-- Created: 2025-11-07
-- Adds visual routine boards with full CRUD operations

-- =============================================
-- BOARDS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.boards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    board_type TEXT NOT NULL CHECK (board_type IN ('routine', 'visual', 'kanban', 'timeline', 'custom')),
    layout TEXT NOT NULL DEFAULT 'linear' CHECK (layout IN ('linear', 'grid', 'kanban', 'timeline', 'freeform')),
    theme TEXT DEFAULT 'default',
    
    -- Configuration
    config JSONB DEFAULT '{
        "showProgress": true,
        "showTimers": true,
        "highlightTransitions": true,
        "allowReordering": true,
        "autoSave": true,
        "pauseBetweenSteps": 0
    }'::jsonb,
    
    -- Schedule settings
    schedule JSONB DEFAULT '{
        "isScheduled": false,
        "frequency": null,
        "daysOfWeek": [],
        "timeOfDay": null,
        "autoStart": false
    }'::jsonb,
    
    -- Visual customization
    visual_settings JSONB DEFAULT '{
        "backgroundColor": "#ffffff",
        "cardStyle": "modern",
        "iconSet": "default",
        "fontSize": "medium",
        "spacing": "normal"
    }'::jsonb,
    
    -- Status and metadata
    is_active BOOLEAN DEFAULT true,
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    share_code TEXT UNIQUE,
    tags TEXT[] DEFAULT '{}',
    
    -- Analytics
    total_executions INTEGER DEFAULT 0,
    last_executed_at TIMESTAMPTZ,
    average_duration INTEGER, -- minutes
    completion_rate DECIMAL(3,2),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.boards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own boards"
    ON public.boards FOR SELECT
    USING (auth.uid() = user_id OR is_public = true);

CREATE POLICY "Users can insert own boards"
    ON public.boards FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own boards"
    ON public.boards FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own boards"
    ON public.boards FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_boards_user_id ON public.boards(user_id);
CREATE INDEX idx_boards_board_type ON public.boards(board_type);
CREATE INDEX idx_boards_is_active ON public.boards(is_active, user_id);
CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
CREATE INDEX idx_boards_tags ON public.boards USING GIN(tags);

-- =============================================
-- BOARD STEPS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    step_type TEXT NOT NULL CHECK (step_type IN ('task', 'flexZone', 'note', 'transition', 'break')),
    title TEXT NOT NULL,
    description TEXT,
    duration INTEGER NOT NULL DEFAULT 0, -- minutes
    order_index INTEGER NOT NULL,
    
    -- Visual customization
    visual_cues JSONB DEFAULT '{
        "color": "#3b82f6",
        "icon": "",
        "emoji": null,
        "backgroundColor": null,
        "borderColor": null
    }'::jsonb,
    
    -- Transition support
    transition_cue JSONB,
    
    -- Flex zone specific
    freeform_data JSONB,
    timer_settings JSONB DEFAULT '{
        "autoStart": false,
        "showWarningAt": null,
        "allowOverrun": true,
        "endNotification": {
            "type": "visual",
            "intensity": "normal"
        }
    }'::jsonb,
    
    -- Neurotype adaptations
    neurotype_adaptations JSONB DEFAULT '{}'::jsonb,
    
    -- Flags
    is_flexible BOOLEAN DEFAULT false,
    is_optional BOOLEAN DEFAULT false,
    is_completed BOOLEAN DEFAULT false,
    
    -- Execution tracking
    execution_state JSONB DEFAULT '{
        "status": "pending",
        "startedAt": null,
        "completedAt": null,
        "actualDuration": null,
        "notes": null
    }'::jsonb,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_steps ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view steps of accessible boards"
    ON public.board_steps FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id 
            AND (user_id = auth.uid() OR is_public = true)
        )
    );

CREATE POLICY "Users can insert steps to own boards"
    ON public.board_steps FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can update steps of own boards"
    ON public.board_steps FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

CREATE POLICY "Users can delete steps from own boards"
    ON public.board_steps FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.boards
            WHERE id = board_steps.board_id AND user_id = auth.uid()
        )
    );

-- Add indexes
CREATE INDEX idx_board_steps_board_id ON public.board_steps(board_id);
CREATE INDEX idx_board_steps_order ON public.board_steps(board_id, order_index);
CREATE INDEX idx_board_steps_type ON public.board_steps(step_type);

-- =============================================
-- BOARD EXECUTIONS TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    board_id UUID NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Execution tracking
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    current_step_id UUID REFERENCES public.board_steps(id) ON DELETE SET NULL,
    total_duration INTEGER, -- minutes
    
    -- Step executions (array of step execution records)
    step_executions JSONB DEFAULT '[]'::jsonb,
    
    -- Interruptions and modifications
    interruptions JSONB DEFAULT '[]'::jsonb,
    modifications JSONB DEFAULT '[]'::jsonb,
    
    -- Completion data
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned', 'paused')),
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    
    -- User feedback
    satisfaction_rating INTEGER CHECK (satisfaction_rating >= 1 AND satisfaction_rating <= 5),
    difficulty_rating INTEGER CHECK (difficulty_rating >= 1 AND difficulty_rating <= 5),
    notes TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_executions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own executions"
    ON public.board_executions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own executions"
    ON public.board_executions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own executions"
    ON public.board_executions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own executions"
    ON public.board_executions FOR DELETE
    USING (auth.uid() = user_id);

-- Add indexes
CREATE INDEX idx_board_executions_board_id ON public.board_executions(board_id);
CREATE INDEX idx_board_executions_user_id ON public.board_executions(user_id);
CREATE INDEX idx_board_executions_started_at ON public.board_executions(started_at);
CREATE INDEX idx_board_executions_status ON public.board_executions(status, user_id);

-- =============================================
-- BOARD TEMPLATES TABLE
-- =============================================
CREATE TABLE IF NOT EXISTS public.board_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('morning', 'evening', 'work', 'self-care', 'exercise', 'study', 'custom')),
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
    
    -- Template structure (copied to boards table)
    template_data JSONB NOT NULL,
    
    -- Neurotype optimization
    neurotype_optimized TEXT[] DEFAULT '{}',
    
    -- Metadata
    is_public BOOLEAN DEFAULT true,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    estimated_duration INTEGER, -- minutes
    tags TEXT[] DEFAULT '{}',
    
    -- Usage stats
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    rating_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE public.board_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Everyone can view public templates"
    ON public.board_templates FOR SELECT
    USING (is_public = true OR auth.uid() = author_id);

CREATE POLICY "Users can create templates"
    ON public.board_templates FOR INSERT
    WITH CHECK (auth.uid() = author_id);

CREATE POLICY "Authors can update own templates"
    ON public.board_templates FOR UPDATE
    USING (auth.uid() = author_id);

CREATE POLICY "Authors can delete own templates"
    ON public.board_templates FOR DELETE
    USING (auth.uid() = author_id);

-- Add indexes
CREATE INDEX idx_board_templates_category ON public.board_templates(category);
CREATE INDEX idx_board_templates_public ON public.board_templates(is_public);
CREATE INDEX idx_board_templates_tags ON public.board_templates USING GIN(tags);
CREATE INDEX idx_board_templates_neurotype ON public.board_templates USING GIN(neurotype_optimized);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_boards_updated_at()
RETURNS TRIGGER AS $anon_263$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_263$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER update_boards_timestamp
    BEFORE UPDATE ON public.boards
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_steps_timestamp
    BEFORE UPDATE ON public.board_steps
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_executions_timestamp
    BEFORE UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

CREATE TRIGGER update_board_templates_timestamp
    BEFORE UPDATE ON public.board_templates
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Function to update board analytics when execution completes
CREATE OR REPLACE FUNCTION update_board_analytics()
RETURNS TRIGGER AS $anon_264$
DECLARE
    avg_dur INTEGER;
    comp_rate DECIMAL(3,2);
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        -- Update board statistics
        UPDATE public.boards
        SET 
            total_executions = total_executions + 1,
            last_executed_at = NEW.completed_at
        WHERE id = NEW.board_id;
        
        -- Calculate average duration
        SELECT AVG(total_duration)::INTEGER INTO avg_dur
        FROM public.board_executions
        WHERE board_id = NEW.board_id AND status = 'completed';
        
        -- Calculate completion rate
        SELECT (COUNT(*) FILTER (WHERE status = 'completed')::DECIMAL / NULLIF(COUNT(*), 0)) INTO comp_rate
        FROM public.board_executions
        WHERE board_id = NEW.board_id;
        
        -- Update analytics
        UPDATE public.boards
        SET 
            average_duration = avg_dur,
            completion_rate = comp_rate
        WHERE id = NEW.board_id;
    END IF;
    
    RETURN NEW;
END;
$anon_264$ LANGUAGE plpgsql;

CREATE TRIGGER update_board_analytics_trigger
    AFTER UPDATE ON public.board_executions
    FOR EACH ROW EXECUTE FUNCTION update_board_analytics();

-- Function to generate share code
CREATE OR REPLACE FUNCTION generate_share_code()
RETURNS TEXT AS $anon_265$
BEGIN
    RETURN substring(md5(random()::text || clock_timestamp()::text) from 1 for 8);
END;
$anon_266$ LANGUAGE plpgsql;

-- =============================================
-- VIEWS FOR ANALYTICS
-- =============================================

-- View for board statistics
CREATE OR REPLACE VIEW board_stats AS
SELECT 
    b.id,
    b.user_id,
    b.title,
    b.board_type,
    b.total_executions,
    b.last_executed_at,
    b.average_duration,
    b.completion_rate,
    COUNT(bs.id) as total_steps,
    COUNT(bs.id) FILTER (WHERE bs.is_optional = false) as required_steps,
    SUM(bs.duration) as estimated_total_duration
FROM public.boards b
LEFT JOIN public.board_steps bs ON b.id = bs.board_id
GROUP BY b.id, b.user_id, b.title, b.board_type, b.total_executions, 
         b.last_executed_at, b.average_duration, b.completion_rate;

-- View for recent board activity
CREATE OR REPLACE VIEW recent_board_activity AS
SELECT 
    be.id as execution_id,
    b.id as board_id,
    b.title as board_title,
    be.user_id,
    be.started_at,
    be.completed_at,
    be.status,
    be.total_duration,
    be.satisfaction_rating,
    be.completion_percentage
FROM public.board_executions be
JOIN public.boards b ON be.board_id = b.id
ORDER BY be.started_at DESC;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.boards TO authenticated;
GRANT ALL ON public.board_steps TO authenticated;
GRANT ALL ON public.board_executions TO authenticated;
GRANT ALL ON public.board_templates TO authenticated;

GRANT SELECT ON board_stats TO authenticated;
GRANT SELECT ON recent_board_activity TO authenticated;
;
-- Board Templates Seed Data
-- Run this after the main board schema migration

-- Morning Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Morning Routine - Simple',
  'A gentle morning routine to start your day with clarity and energy',
  'morning',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 30
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF5E6',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Wake Up & Stretch',
        'description', 'Gentle stretching to wake up your body',
        'duration', 5,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#FFA500', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate',
        'description', 'Drink a glass of water to rehydrate',
        'duration', 2,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#4A90E2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Morning Hygiene',
        'description', 'Brush teeth, wash face, get ready',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#50E3C2', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Breakfast',
        'description', 'Eat a healthy breakfast',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F5A623', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Plan Your Day',
        'description', 'Review tasks and set intentions',
        'duration', 5,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#9013FE', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  37,
  ARRAY['morning', 'routine', 'simple', 'beginner']
);

-- Evening Wind Down (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Evening Wind Down',
  'A calming evening routine to prepare for restful sleep',
  'evening',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#2C3E50',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Tidy Up',
        'description', 'Quick 10-minute cleanup of main spaces',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Evening Hygiene',
        'description', 'Brush teeth, skincare routine',
        'duration', 8,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#60A5FA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Prepare Tomorrow',
        'description', 'Lay out clothes, pack bag, check calendar',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Calm Activity',
        'description', 'Read, journal, or meditate',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#A78BFA', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Bedtime',
        'description', 'Get into bed, lights off',
        'duration', 2,
        'order_index', 4,
        'visual_cues', jsonb_build_object('color', '#1E293B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  40,
  ARRAY['evening', 'routine', 'sleep', 'wind-down']
);

-- Pomodoro Work Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Pomodoro Work Session',
  'Classic 25-5 Pomodoro technique for focused work',
  'work',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', false,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'minimal',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Deep work - no distractions',
        'duration', 25,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Short Break',
        'description', 'Stand, stretch, hydrate',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Focus Work',
        'description', 'Continue deep work',
        'duration', 25,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'prominent')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Long Break',
        'description', 'Walk around, get fresh air',
        'duration', 15,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['work', 'focus', 'pomodoro', 'productivity']
);

-- Quick Exercise Routine (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Quick Exercise Break',
  '15-minute energizing movement routine',
  'exercise',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'routine',
      'layout', 'grid',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 10
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#ECFDF5',
        'cardStyle', 'colorful',
        'iconSet', 'playful',
        'fontSize', 'large',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Warm Up',
        'description', 'Light cardio to get blood flowing',
        'duration', 3,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', false,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Stretches',
        'description', 'Full body stretching',
        'duration', 5,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Strength Exercises',
        'description', 'Bodyweight exercises (push-ups, squats)',
        'duration', 5,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#EF4444', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Cool Down',
        'description', 'Light stretching and deep breathing',
        'duration', 2,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#06B6D4', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 30,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'sensory-regulation'],
  true,
  15,
  ARRAY['exercise', 'movement', 'energy', 'quick']
);

-- Self-Care Hour (Beginner)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Self-Care Hour',
  'Dedicated time for rest and restoration',
  'self-care',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'freeform',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', false,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFF1F2',
        'cardStyle', 'modern',
        'iconSet', 'playful',
        'fontSize', 'medium',
        'spacing', 'spacious'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'flexZone',
        'title', 'Choose Your Activity',
        'description', 'Pick what feels right: bath, music, art, nature walk',
        'duration', 30,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#EC4899', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', false,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Hydrate & Snack',
        'description', 'Nourish your body',
        'duration', 10,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Reflection',
        'description', 'Journal or meditate on your feelings',
        'duration', 15,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 180,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'visual', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Gratitude',
        'description', 'List 3 things you''re grateful for',
        'duration', 5,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 60,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', true,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['autism', 'burnout-prevention', 'sensory-regulation'],
  true,
  60,
  ARRAY['self-care', 'wellness', 'rest', 'restoration']
);

-- Study Session (Intermediate)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Effective Study Session',
  'Structured study routine with breaks',
  'study',
  'intermediate',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'kanban',
      'layout', 'linear',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', false,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#EFF6FF',
        'cardStyle', 'modern',
        'iconSet', 'professional',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array(
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Review Notes',
        'description', 'Quick review of previous material',
        'duration', 10,
        'order_index', 0,
        'visual_cues', jsonb_build_object('color', '#3B82F6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Active Learning',
        'description', 'Read, take notes, solve problems',
        'duration', 30,
        'order_index', 1,
        'visual_cues', jsonb_build_object('color', '#8B5CF6', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 300,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'break',
        'title', 'Break',
        'description', 'Rest your brain',
        'duration', 10,
        'order_index', 2,
        'visual_cues', jsonb_build_object('color', '#10B981', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 120,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'audio', 'intensity', 'subtle')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', true,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      ),
      jsonb_build_object(
        'step_type', 'task',
        'title', 'Practice & Review',
        'description', 'Test yourself, review key concepts',
        'duration', 20,
        'order_index', 3,
        'visual_cues', jsonb_build_object('color', '#F59E0B', 'icon', ''),
        'timer_settings', jsonb_build_object(
          'autoStart', true,
          'showWarningAt', 240,
          'allowOverrun', true,
          'endNotification', jsonb_build_object('type', 'all', 'intensity', 'normal')
        ),
        'neurotype_adaptations', jsonb_build_object(),
        'is_flexible', false,
        'is_optional', false,
        'is_completed', false,
        'execution_state', jsonb_build_object('status', 'pending')
      )
    )
  ),
  ARRAY['adhd', 'executive-function'],
  true,
  70,
  ARRAY['study', 'learning', 'focus', 'education']
);

-- Blank Custom Template (All Levels)
INSERT INTO board_templates (
  name,
  description,
  category,
  difficulty,
  template_data,
  neurotype_optimized,
  is_public,
  estimated_duration,
  tags
) VALUES (
  'Blank Canvas',
  'Start from scratch - build your perfect board',
  'custom',
  'beginner',
  jsonb_build_object(
    'board', jsonb_build_object(
      'board_type', 'custom',
      'layout', 'freeform',
      'config', jsonb_build_object(
        'showProgress', true,
        'showTimers', true,
        'highlightTransitions', true,
        'allowReordering', true,
        'autoSave', true,
        'pauseBetweenSteps', 0
      ),
      'visual_settings', jsonb_build_object(
        'backgroundColor', '#FFFFFF',
        'cardStyle', 'modern',
        'iconSet', 'default',
        'fontSize', 'medium',
        'spacing', 'normal'
      )
    ),
    'steps', jsonb_build_array()
  ),
  ARRAY['adhd', 'autism', 'executive-function'],
  true,
  0,
  ARRAY['custom', 'blank', 'flexible']
);
;
-- =============================================
-- Migration: AI Integration
-- Created: 2025-11-07
-- Adds AI conversation tracking, suggestions, and usage monitoring
-- =============================================

-- =============================================
-- AI CONVERSATIONS TABLE
-- Stores complete conversation history with context
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_type TEXT NOT NULL CHECK (conversation_type IN (
        'general',
        'board_suggestion',
        'task_breakdown',
        'mood_insight',
        'context_recall',
        'routine_creation'
    )),
    
    -- Context linking to other entities
    context_data JSONB, -- {board_id, task_id, mood_entry_id, etc.}
    
    -- Conversation history (array of messages)
    messages JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    tokens_used INTEGER DEFAULT 0,
    model_used TEXT,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Quality and safety tracking
    user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
    user_feedback TEXT,
    flagged_for_review BOOLEAN DEFAULT false,
    flag_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI conversations"
    ON public.ai_conversations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI conversations"
    ON public.ai_conversations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI conversations"
    ON public.ai_conversations FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI conversations"
    ON public.ai_conversations FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_conversations_user_id ON public.ai_conversations(user_id);
CREATE INDEX idx_ai_conversations_type ON public.ai_conversations(conversation_type);
CREATE INDEX idx_ai_conversations_created ON public.ai_conversations(created_at DESC);
CREATE INDEX idx_ai_conversations_flagged ON public.ai_conversations(flagged_for_review) 
    WHERE flagged_for_review = true;

-- =============================================
-- AI SUGGESTIONS TABLE
-- Stores AI-generated suggestions for boards, tasks, etc.
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_suggestions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN (
        'board',
        'task',
        'routine',
        'habit',
        'mood_coping',
        'energy_management'
    )),
    
    -- Source
    conversation_id UUID REFERENCES public.ai_conversations(id) ON DELETE SET NULL,
    trigger_context JSONB, -- What prompted this suggestion
    
    -- Suggestion content
    title TEXT NOT NULL,
    description TEXT,
    suggestion_data JSONB NOT NULL, -- Actual board structure, task list, etc.
    
    -- User interaction
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending',
        'accepted',
        'rejected',
        'modified',
        'implemented'
    )),
    user_modifications JSONB,
    implemented_at TIMESTAMPTZ,
    implemented_id TEXT, -- ID of the created board/task/etc.
    
    -- Analytics
    confidence_score DECIMAL(3,2), -- AI's confidence in suggestion (0.00-1.00)
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE public.ai_suggestions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI suggestions"
    ON public.ai_suggestions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI suggestions"
    ON public.ai_suggestions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own AI suggestions"
    ON public.ai_suggestions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own AI suggestions"
    ON public.ai_suggestions FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_suggestions_user_id ON public.ai_suggestions(user_id);
CREATE INDEX idx_ai_suggestions_type ON public.ai_suggestions(suggestion_type);
CREATE INDEX idx_ai_suggestions_status ON public.ai_suggestions(status);
CREATE INDEX idx_ai_suggestions_created ON public.ai_suggestions(created_at DESC);

-- =============================================
-- AI USAGE STATS TABLE
-- Tracks usage for rate limiting and cost management
-- =============================================
CREATE TABLE IF NOT EXISTS public.ai_usage_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage metrics
    total_requests INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10,4) DEFAULT 0, -- Estimated cost in USD
    
    -- Breakdown by type
    requests_by_type JSONB DEFAULT '{}'::jsonb,
    tokens_by_model JSONB DEFAULT '{}'::jsonb,
    
    -- Hourly tracking for rate limiting
    hourly_requests JSONB DEFAULT '{}'::jsonb, -- {hour: count}
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, date)
);

-- RLS Policies
ALTER TABLE public.ai_usage_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own usage stats"
    ON public.ai_usage_stats FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own usage stats"
    ON public.ai_usage_stats FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own usage stats"
    ON public.ai_usage_stats FOR UPDATE
    USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_ai_usage_user_date ON public.ai_usage_stats(user_id, date DESC);
CREATE INDEX idx_ai_usage_date ON public.ai_usage_stats(date DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update updated_at timestamp for ai_conversations
CREATE TRIGGER update_ai_conversations_timestamp
    BEFORE UPDATE ON public.ai_conversations
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_suggestions
CREATE TRIGGER update_ai_suggestions_timestamp
    BEFORE UPDATE ON public.ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- Update updated_at timestamp for ai_usage_stats
CREATE TRIGGER update_ai_usage_stats_timestamp
    BEFORE UPDATE ON public.ai_usage_stats
    FOR EACH ROW EXECUTE FUNCTION update_boards_updated_at();

-- =============================================
-- FUNCTIONS
-- =============================================

-- Function to increment AI usage statistics
-- Called after each AI request
CREATE OR REPLACE FUNCTION increment_ai_usage(
    p_user_id UUID,
    p_date DATE,
    p_requests INTEGER,
    p_tokens INTEGER,
    p_cost DECIMAL,
    p_type TEXT,
    p_model TEXT
)
RETURNS VOID AS $anon_266$
DECLARE
    v_hour TEXT;
    v_requests_by_type JSONB;
    v_tokens_by_model JSONB;
    v_hourly_requests JSONB;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Insert or update usage stats
    INSERT INTO public.ai_usage_stats (
        user_id,
        date,
        total_requests,
        total_tokens,
        total_cost,
        requests_by_type,
        tokens_by_model,
        hourly_requests
    ) VALUES (
        p_user_id,
        p_date,
        p_requests,
        p_tokens,
        p_cost,
        jsonb_build_object(p_type, p_requests),
        jsonb_build_object(p_model, p_tokens),
        jsonb_build_object(v_hour, p_requests)
    )
    ON CONFLICT (user_id, date) DO UPDATE SET
        total_requests = ai_usage_stats.total_requests + p_requests,
        total_tokens = ai_usage_stats.total_tokens + p_tokens,
        total_cost = ai_usage_stats.total_cost + p_cost,
        requests_by_type = ai_usage_stats.requests_by_type || 
            jsonb_build_object(
                p_type, 
                COALESCE((ai_usage_stats.requests_by_type->p_type)::INTEGER, 0) + p_requests
            ),
        tokens_by_model = ai_usage_stats.tokens_by_model || 
            jsonb_build_object(
                p_model,
                COALESCE((ai_usage_stats.tokens_by_model->p_model)::INTEGER, 0) + p_tokens
            ),
        hourly_requests = ai_usage_stats.hourly_requests || 
            jsonb_build_object(
                v_hour,
                COALESCE((ai_usage_stats.hourly_requests->v_hour)::INTEGER, 0) + p_requests
            ),
        updated_at = NOW();
END;
$anon_267$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has exceeded rate limits
CREATE OR REPLACE FUNCTION check_ai_rate_limit(
    p_user_id UUID,
    p_hourly_limit INTEGER DEFAULT 20,
    p_daily_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    within_limits BOOLEAN,
    hourly_count INTEGER,
    daily_count INTEGER
) AS $anon_267$
DECLARE
    v_hour TEXT;
    v_hourly_count INTEGER;
    v_daily_count INTEGER;
BEGIN
    v_hour := EXTRACT(HOUR FROM NOW())::TEXT;
    
    -- Get today's usage
    SELECT 
        COALESCE((hourly_requests->v_hour)::INTEGER, 0),
        COALESCE(total_requests, 0)
    INTO v_hourly_count, v_daily_count
    FROM public.ai_usage_stats
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, set counts to 0
    v_hourly_count := COALESCE(v_hourly_count, 0);
    v_daily_count := COALESCE(v_daily_count, 0);
    
    -- Return results
    RETURN QUERY SELECT
        (v_hourly_count < p_hourly_limit AND v_daily_count < p_daily_limit),
        v_hourly_count,
        v_daily_count;
END;
$anon_268$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- VIEWS
-- =============================================

-- View for AI usage analytics
CREATE OR REPLACE VIEW ai_usage_summary AS
SELECT 
    u.id as user_id,
    u.email,
    DATE_TRUNC('day', aus.created_at) as date,
    SUM(aus.total_requests) as requests,
    SUM(aus.total_tokens) as tokens,
    SUM(aus.total_cost) as cost,
    COUNT(DISTINCT ac.id) as conversations,
    COUNT(DISTINCT asug.id) as suggestions_created,
    COUNT(DISTINCT asug.id) FILTER (WHERE asug.status = 'implemented') as suggestions_implemented
FROM auth.users u
LEFT JOIN public.ai_usage_stats aus ON u.id = aus.user_id
LEFT JOIN public.ai_conversations ac ON u.id = ac.user_id
LEFT JOIN public.ai_suggestions asug ON u.id = asug.user_id
GROUP BY u.id, u.email, DATE_TRUNC('day', aus.created_at);

-- View for conversation insights
CREATE OR REPLACE VIEW conversation_insights AS
SELECT 
    ac.id,
    ac.user_id,
    ac.conversation_type,
    ac.model_used,
    ac.tokens_used,
    ac.user_rating,
    ac.started_at,
    ac.last_message_at,
    (ac.last_message_at - ac.started_at) as conversation_duration,
    jsonb_array_length(ac.messages) as message_count,
    COUNT(asug.id) as suggestions_generated
FROM public.ai_conversations ac
LEFT JOIN public.ai_suggestions asug ON ac.id = asug.conversation_id
GROUP BY ac.id;

-- =============================================
-- GRANT PERMISSIONS
-- =============================================

GRANT ALL ON public.ai_conversations TO authenticated;
GRANT ALL ON public.ai_suggestions TO authenticated;
GRANT ALL ON public.ai_usage_stats TO authenticated;

GRANT SELECT ON ai_usage_summary TO authenticated;
GRANT SELECT ON conversation_insights TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION increment_ai_usage TO authenticated;
GRANT EXECUTE ON FUNCTION check_ai_rate_limit TO authenticated;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE public.ai_conversations IS 'Stores complete AI conversation history with context and quality tracking';
COMMENT ON TABLE public.ai_suggestions IS 'AI-generated suggestions for boards, tasks, routines, and coping strategies';
COMMENT ON TABLE public.ai_usage_stats IS 'Daily usage statistics for rate limiting and cost management';

COMMENT ON FUNCTION increment_ai_usage IS 'Updates AI usage statistics after each request';
COMMENT ON FUNCTION check_ai_rate_limit IS 'Checks if user has exceeded hourly or daily rate limits';
;
-- Migration: Add missing tables required by the application
-- Created: 2025-11-08
-- Purpose: Add time_blocks and task_templates tables that are referenced in code

-- =============================================
-- TIME BLOCKS TABLE
-- =============================================
-- Stores calendar time blocks for scheduling tasks
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB, -- iCal RRULE format
    color TEXT DEFAULT '#3B82F6', -- Default blue
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

-- Add indexes for performance
CREATE INDEX idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX idx_time_blocks_end_time ON public.time_blocks(end_time);

-- Enable RLS
ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- =============================================
-- TASK TEMPLATES TABLE
-- =============================================
-- Stores reusable task templates for quick task creation
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL, -- minutes
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false, -- Allow sharing templates
    usage_count INTEGER DEFAULT 0, -- Track popularity
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX idx_task_templates_category ON public.task_templates(category);
CREATE INDEX idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

-- Enable RLS
ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- UPDATE TRIGGERS
-- =============================================
-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_268$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_268$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- SEED DEFAULT TASK TEMPLATES
-- =============================================
-- Add some default public templates for new users
-- Note: This requires a system user_id. Adjust UUID as needed or create from app.
-- For now, these are commented out. Create them from the application instead.

/*
INSERT INTO public.task_templates (user_id, name, description, category, priority, estimated_duration, tags, is_public, usage_count)
VALUES 
    ('00000000-0000-0000-0000-000000000000', 'Quick Email Response', 'Respond to urgent email', 'work', 'high', 15, ARRAY['email', 'communication'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Morning Exercise', '30-minute workout routine', 'health', 'medium', 30, ARRAY['exercise', 'morning'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Grocery Shopping', 'Weekly grocery run', 'personal', 'medium', 60, ARRAY['errands', 'shopping'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Code Review', 'Review pull requests', 'work', 'medium', 45, ARRAY['development', 'code-review'], true, 0),
    ('00000000-0000-0000-0000-000000000000', 'Meditation Break', '10-minute mindfulness session', 'self-care', 'low', 10, ARRAY['meditation', 'wellness'], true, 0);
*/

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON TABLE public.time_blocks IS 'Calendar time blocks for scheduling tasks and events';
COMMENT ON TABLE public.task_templates IS 'Reusable task templates for quick task creation';

COMMENT ON COLUMN public.time_blocks.recurrence_rule IS 'iCalendar RRULE format for recurring events';
COMMENT ON COLUMN public.task_templates.usage_count IS 'Number of times this template has been used';
COMMENT ON COLUMN public.task_templates.is_public IS 'Whether this template is shared with all users';
;
-- Migration: Schema Updates and Fixes
-- Created: 2025-11-08
-- Purpose: Add missing columns and update existing tables to match application requirements

-- =============================================
-- TASKS TABLE UPDATES
-- =============================================
-- Ensure tasks table has all required columns for calendar scheduling

-- Add scheduled_at if it doesn't exist (for calendar time blocking)
DO $anon_269$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'scheduled_at'
    ) THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS scheduled_at TIMESTAMPTZ;
    END IF;
END $anon_270$;
;
-- Add actual_duration if it doesn't exist
DO $anon_270$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'actual_duration'
    ) THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS actual_duration INTEGER;
    END IF;
END $anon_271$;
;
-- Add buffer_time if it doesn't exist
DO $anon_271$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'buffer_time'
    ) THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS buffer_time INTEGER DEFAULT 0;
    END IF;
END $anon_272$;
;
-- Add completed_at if it doesn't exist
DO $anon_272$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'tasks' 
        AND column_name = 'completed_at'
    ) THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS completed_at TIMESTAMPTZ;
    END IF;
END $anon_273$;
;
-- =============================================
-- BOARDS TABLE UPDATES
-- =============================================
-- Ensure boards table has share_code and is_public

-- Add share_code if it doesn't exist
DO $anon_273$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'share_code'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN share_code TEXT UNIQUE;
        CREATE INDEX idx_boards_share_code ON public.boards(share_code) WHERE share_code IS NOT NULL;
    END IF;
END $anon_274$;
;
-- Add is_public if it doesn't exist
DO $anon_274$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'boards' 
        AND column_name = 'is_public'
    ) THEN
        ALTER TABLE public.boards ADD COLUMN is_public BOOLEAN DEFAULT false;
        CREATE INDEX idx_boards_is_public ON public.boards(is_public) WHERE is_public = true;
    END IF;
END $anon_275$;
;
-- =============================================
-- USER_ACTIVITY TABLE UPDATES
-- =============================================
-- Ensure user_activity context field is properly typed

-- Add comment to clarify context JSONB usage
COMMENT ON COLUMN public.user_activity.context IS 'Flexible JSONB field for storing activity-specific data. For analytics activities, stores metrics like tasksCompleted, averageCompletionTime, productivityScore, streakDays, etc.';

-- =============================================
-- NOTIFICATIONS TABLE UPDATES
-- =============================================
-- Ensure notifications table exists and has proper structure

-- Check if notifications table exists, if not create it
DO $anon_275$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'notifications'
    ) THEN
        -- Create notifications type if it doesn't exist
        DO $notification_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
                CREATE TYPE notification_type AS ENUM (
                    'reminder', 'celebration', 'suggestion', 'warning', 'update', 'social'
                );
            END IF;
        END $notification_type$;

        -- Create priority type if it doesn't exist (may already exist from tasks)
        DO $priority_type$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_priority') THEN
                CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');
            END IF;
        END $priority_type$;

        -- Create the notifications table
        CREATE TABLE public.notifications (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
            type notification_type NOT NULL,
            title TEXT NOT NULL,
            message TEXT NOT NULL,
            priority notification_priority DEFAULT 'medium',
            actionable BOOLEAN DEFAULT false,
            actions JSONB DEFAULT '[]', -- Array of action buttons
            scheduled_for TIMESTAMPTZ,
            delivered_at TIMESTAMPTZ,
            read_at TIMESTAMPTZ,
            dismissed_at TIMESTAMPTZ,
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Add indexes
        CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
        CREATE INDEX idx_notifications_delivered_at ON public.notifications(delivered_at);
        CREATE INDEX idx_notifications_read_at ON public.notifications(read_at) WHERE read_at IS NULL;
        CREATE INDEX idx_notifications_scheduled_for ON public.notifications(scheduled_for) WHERE scheduled_for IS NOT NULL;

        -- Enable RLS
        ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

        -- RLS Policies
        CREATE POLICY "Users can view own notifications"
            ON public.notifications FOR SELECT
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can insert own notifications"
            ON public.notifications FOR INSERT
            WITH CHECK (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can update own notifications"
            ON public.notifications FOR UPDATE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        CREATE POLICY "Users can delete own notifications"
            ON public.notifications FOR DELETE
            USING (auth.uid() IN (
                SELECT id FROM auth.users 
                WHERE id IN (SELECT id FROM user_profiles WHERE id = notifications.user_id)
            ));

        -- Add update trigger
        CREATE TRIGGER update_notifications_updated_at
            BEFORE UPDATE ON public.notifications
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $anon_276$;

-- =============================================
-- DATA VALIDATION
-- =============================================
-- Add constraints to ensure data integrity

-- Ensure time_blocks have valid time ranges
ALTER TABLE public.time_blocks DROP CONSTRAINT IF EXISTS valid_time_range;
ALTER TABLE public.time_blocks ADD CONSTRAINT valid_time_range 
    CHECK (end_time > start_time);

-- Ensure task estimated_duration is positive
DO $anon_276$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'tasks' AND constraint_name = 'positive_estimated_duration'
    ) THEN
        ALTER TABLE public.tasks ADD CONSTRAINT positive_estimated_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_277$;

-- Ensure task_templates estimated_duration is positive
DO $anon_277$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.constraint_column_usage 
        WHERE table_name = 'task_templates' AND constraint_name = 'positive_template_duration'
    ) THEN
        ALTER TABLE public.task_templates ADD CONSTRAINT positive_template_duration 
            CHECK (estimated_duration > 0);
    END IF;
END $anon_278$;

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
-- Add missing indexes for common queries

-- Tasks indexes
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_user_id ON public.user_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_type ON public.user_activity(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_started_at ON public.user_activity(started_at);

-- =============================================
-- COMMENTS AND DOCUMENTATION
-- =============================================
COMMENT ON COLUMN public.tasks.scheduled_at IS 'Specific date/time when task is scheduled on calendar';
COMMENT ON COLUMN public.tasks.due_date IS 'Deadline for task completion';
COMMENT ON COLUMN public.tasks.actual_duration IS 'Actual time spent on task in minutes';
COMMENT ON COLUMN public.tasks.buffer_time IS 'Extra time buffer in minutes for transitions';
COMMENT ON COLUMN public.tasks.completed_at IS 'Timestamp when task was marked complete';

COMMENT ON COLUMN public.boards.share_code IS 'Unique code for sharing board with others';
COMMENT ON COLUMN public.boards.is_public IS 'Whether board is publicly accessible via share code';
;
-- Persist manual Priority Matrix assignment directly on tasks
begin;
;
alter table public.tasks
  add column if not exists quadrant text
  check (quadrant in (
    'urgent-important',
    'urgent-not-important',
    'not-urgent-important',
    'not-urgent-not-important'
  ))
  default 'not-urgent-not-important';

update public.tasks
set quadrant = case
  when priority in ('high', 'urgent') and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-important'
  when priority in ('high', 'urgent') and (due_date is null or due_date > (now() + interval '2 days')) then 'not-urgent-important'
  when (priority is null or priority not in ('high', 'urgent')) and due_date is not null and due_date <= (now() + interval '2 days') then 'urgent-not-important'
  else 'not-urgent-not-important'
end;

create index if not exists idx_tasks_quadrant on public.tasks(quadrant);

commit;
;
-- Medication & Health + Diet schema additions
begin;
;
-- Enums
do $anon_278$
begin
  if not exists (select 1 from pg_type where typname = 'routine_step_type') then
    null;
  end if;
  if not exists (select 1 from pg_type where typname = 'medication_intake_context') then
    create type medication_intake_context as enum ('morning', 'midday', 'evening', 'bedtime', 'custom');
  end if;

  if not exists (select 1 from pg_type where typname = 'treatment_channel') then
    create type treatment_channel as enum ('therapy', 'occupational', 'pt', 'coaching', 'medical');
  end if;

  if not exists (select 1 from pg_type where typname = 'nutrition_entry_type') then
    create type nutrition_entry_type as enum ('meal', 'snack', 'drink', 'supplement');
  end if;
end $anon_279$;
;
alter type routine_step_type add value if not exists 'medication';
alter type routine_step_type add value if not exists 'health';

alter table if exists routine_steps
  add column if not exists extensions jsonb;

-- Medication plans
create table if not exists medication_regimens (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  name text not null,
  description text,
  provider_name text,
  color_token text,
  sensory_considerations text,
  adherence_goal integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists medication_doses (
  id uuid primary key default uuid_generate_v4(),
  regimen_id uuid not null references medication_regimens(id) on delete cascade,
  routine_step_id uuid references routine_steps(step_id) on delete set null,
  label text not null,
  dosage text not null,
  instructions text,
  requires_food boolean default false,
  intake_window medication_intake_context default 'morning',
  scheduled_time time,
  prn boolean default false,
  reminders jsonb default '{}'::jsonb,
  side_effect_watchlist text[],
  last_taken_at timestamptz,
  streak integer default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Treatment tracking
create table if not exists treatment_sessions (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  routine_id uuid references routines(id) on delete set null,
  channel treatment_channel not null,
  focus_areas text[],
  provider text,
  cadence text,
  meeting_link text,
  prep_template jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists treatment_check_ins (
  id uuid primary key default uuid_generate_v4(),
  session_id uuid not null references treatment_sessions(id) on delete cascade,
  occurred_at timestamptz not null default now(),
  mood_before integer,
  mood_after integer,
  energy_before integer,
  energy_after integer,
  highlights jsonb,
  blockers jsonb,
  homework jsonb,
  ai_summary text,
  created_at timestamptz default now()
);

-- Health & diet journaling
create table if not exists health_nutrition_entries (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  entry_type nutrition_entry_type not null,
  title text not null,
  description text,
  occurred_at timestamptz not null default now(),
  sensory_profile jsonb,
  energy_before integer,
  energy_after integer,
  mood_shift integer,
  hydration_score integer,
  tags text[],
  ai_recommendation jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists health_insight_snapshots (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references user_profiles(id) on delete cascade,
  window_start timestamptz not null,
  window_end timestamptz not null,
  adherence jsonb,
  correlations jsonb,
  next_actions jsonb,
  generated_at timestamptz default now()
);

-- Indexes
create index if not exists idx_medication_regimens_user on medication_regimens(user_id);
create index if not exists idx_medication_doses_regimen on medication_doses(regimen_id);
create index if not exists idx_medication_doses_routine_step on medication_doses(routine_step_id);

create index if not exists idx_treatment_sessions_user on treatment_sessions(user_id);
create index if not exists idx_treatment_sessions_routine on treatment_sessions(routine_id);
create index if not exists idx_treatment_checkins_session on treatment_check_ins(session_id);

create index if not exists idx_health_entries_user on health_nutrition_entries(user_id);
create index if not exists idx_health_entries_type on health_nutrition_entries(entry_type);
create index if not exists idx_health_insights_user on health_insight_snapshots(user_id);

-- RLS
alter table if exists medication_regimens enable row level security;
alter table if exists medication_doses enable row level security;
alter table if exists treatment_sessions enable row level security;
alter table if exists treatment_check_ins enable row level security;
alter table if exists health_nutrition_entries enable row level security;
alter table if exists health_insight_snapshots enable row level security;

drop policy if exists "Users manage medication regimens" on medication_regimens;
create policy "Users manage medication regimens" on medication_regimens
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage medication doses" on medication_doses;
create policy "Users manage medication doses" on medication_doses
  for all using (
    exists (
      select 1 from medication_regimens
      where medication_regimens.id = medication_doses.regimen_id
      and medication_regimens.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage treatment sessions" on treatment_sessions;
create policy "Users manage treatment sessions" on treatment_sessions
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage treatment check-ins" on treatment_check_ins;
create policy "Users manage treatment check-ins" on treatment_check_ins
  for all using (
    exists (
      select 1 from treatment_sessions
      where treatment_sessions.id = treatment_check_ins.session_id
      and treatment_sessions.user_id = auth.uid()
    )
  );

drop policy if exists "Users manage health entries" on health_nutrition_entries;
create policy "Users manage health entries" on health_nutrition_entries
  for all using (auth.uid() = user_id);

drop policy if exists "Users manage health insights" on health_insight_snapshots;
create policy "Users manage health insights" on health_insight_snapshots
  for all using (auth.uid() = user_id);

-- Update triggers
create trigger update_medication_regimens_updated_at
  before update on medication_regimens
  for each row execute function update_updated_at_column();

create trigger update_medication_doses_updated_at
  before update on medication_doses
  for each row execute function update_updated_at_column();

create trigger update_treatment_sessions_updated_at
  before update on treatment_sessions
  for each row execute function update_updated_at_column();

create trigger update_health_entries_updated_at
  before update on health_nutrition_entries
  for each row execute function update_updated_at_column();

commit;
;
-- Routine analytics view to drive dashboard hero stats
DROP VIEW IF EXISTS routine_analytics_view;
;
-- Migration: create table for metric ingestion rejections
-- This table stores lightweight records of rejected ingestion attempts
-- so that operators can investigate abuse or malformed payloads.

CREATE TABLE IF NOT EXISTS public.app_metrics_rejections (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  ip inet,
  user_id uuid,
  reason text,
  content_length integer,
  note text,
  payload jsonb,
  created_at timestamptz DEFAULT now()
);
;
-- Keep this migration idempotent. No RLS is necessary because Edge Function uses
-- the service role key to insert, but if you want to restrict insertions later,
-- add RLS policies guarded by an admin role.
;
-- Migration: Add app_metrics table for storing client metrics snapshots
-- Created: 2025-11-20

CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Minimal board_collaborators table to satisfy snapshot policies
-- This is intentionally lightweight and idempotent. The full collaboration
-- schema lives under `src/features/collaboration/database/schema.sql`.

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS public.board_collaborators (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id uuid NOT NULL REFERENCES public.boards(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'viewer',
  can_edit boolean DEFAULT FALSE,
  can_delete boolean DEFAULT FALSE,
  can_invite boolean DEFAULT FALSE,
  status text DEFAULT 'accepted',
  invited_by uuid,
  invited_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_board_collaborators_board_id ON public.board_collaborators(board_id);
CREATE INDEX IF NOT EXISTS idx_board_collaborators_user_id ON public.board_collaborators(user_id);

-- Note: this minimal table is intended as a safe migration to unblock
-- `20251120_add_template_snapshots.sql`. Replace with full collaboration
-- migrations when ready.
;
-- This migration has been intentionally disabled.
-- The `run_sql` RPC is a development convenience that allows executing
-- arbitrary SQL via a function. That's unsafe in production so the file
-- has been disabled. If you need a developer-only RPC, create it manually
-- in a non-production environment with strict access controls.

-- Migration disabled on: TODO: replace with date or commit
;
-- Create snapshot tables for board and routine templates so users can branch
-- templates into private snapshots that they own. Includes Row Level Security
-- policies that allow owners and collaborators to access snapshots.

-- Board snapshots
CREATE TABLE IF NOT EXISTS public.board_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.board_snapshots IS 'User-owned snapshots created from board templates for branching/collaboration.';

-- Enable RLS
ALTER TABLE public.board_snapshots ENABLE ROW LEVEL SECURITY;

-- Owners can select/update/delete their snapshots
CREATE POLICY "board_snapshots_owner_manage" ON public.board_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

-- Allow collaborators on the original template's board to select snapshots
CREATE POLICY "board_snapshots_collaborators_select" ON public.board_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.board_collaborators bc WHERE bc.board_id = public.board_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Allow authenticated users to create snapshots, but enforce owner_id matches auth.uid()
CREATE POLICY "board_snapshots_insert_auth" ON public.board_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Routine snapshots
CREATE TABLE IF NOT EXISTS public.routine_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL,
  owner_id uuid NOT NULL,
  snapshot_data jsonb NOT NULL,
  title text,
  is_public boolean DEFAULT false,
  shared_with jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

COMMENT ON TABLE public.routine_snapshots IS 'User-owned snapshots created from routine templates for branching/collaboration.';

ALTER TABLE public.routine_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "routine_snapshots_owner_manage" ON public.routine_snapshots
  USING (owner_id = auth.uid())
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_insert_auth" ON public.routine_snapshots
  FOR INSERT
  WITH CHECK (owner_id = auth.uid());

CREATE POLICY "routine_snapshots_collaborators_select" ON public.routine_snapshots
  FOR SELECT
  USING (
    owner_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.routines r JOIN public.board_collaborators bc ON bc.board_id = r.id WHERE r.id = public.routine_snapshots.template_id AND bc.user_id = auth.uid()
    )
  );

-- Simple indexes for queries
CREATE INDEX IF NOT EXISTS idx_board_snapshots_owner ON public.board_snapshots(owner_id);
CREATE INDEX IF NOT EXISTS idx_routine_snapshots_owner ON public.routine_snapshots(owner_id);
;
-- Migration: Add visual_routines, mood_entries, sensory_preferences, user_activity tables
-- and RLS policies. Created: 2025-11-20

-- Ensure pgcrypto is available for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;
;
-- Visual routines
CREATE TABLE IF NOT EXISTS public.visual_routines (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  title text NOT NULL,
  steps jsonb DEFAULT '[]'::jsonb,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- Ensure timestamp columns exist if table pre-existed without them
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
ALTER TABLE public.visual_routines ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_visual_routines_updated_at ON public.visual_routines (updated_at DESC);

-- Mood entries
CREATE TABLE IF NOT EXISTS public.mood_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mood smallint,
  notes text,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now()
);
ALTER TABLE public.mood_entries ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_mood_entries_timestamp ON public.mood_entries (timestamp DESC);

-- Sensory preferences
CREATE TABLE IF NOT EXISTS public.sensory_preferences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  preferences jsonb DEFAULT '{}'::jsonb,
  timestamp timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS timestamp timestamptz DEFAULT now();
ALTER TABLE public.sensory_preferences ADD COLUMN IF NOT EXISTS updated_at timestamptz DEFAULT now();
CREATE UNIQUE INDEX IF NOT EXISTS ux_sensory_preferences_user ON public.sensory_preferences (user_id);

-- User activity (analytics / adaptive smart)
CREATE TABLE IF NOT EXISTS public.user_activity (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_type text,
  entity_id text,
  entity_type text,
  duration_minutes int,
  context jsonb DEFAULT '{}'::jsonb,
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz DEFAULT now()
);
ALTER TABLE public.user_activity ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();
CREATE INDEX IF NOT EXISTS idx_user_activity_created_at ON public.user_activity (created_at DESC);

-- Enable Row Level Security and add basic owner-only policies
ALTER TABLE public.visual_routines ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS visual_routines_owner ON public.visual_routines;
CREATE POLICY visual_routines_owner ON public.visual_routines
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.mood_entries ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS mood_entries_owner ON public.mood_entries;
CREATE POLICY mood_entries_owner ON public.mood_entries
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.sensory_preferences ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS sensory_preferences_owner ON public.sensory_preferences;
CREATE POLICY sensory_preferences_owner ON public.sensory_preferences
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.user_activity ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS user_activity_owner ON public.user_activity;
CREATE POLICY user_activity_owner ON public.user_activity
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Note: To create a storage bucket for routine assets, run this command in SQL playground or via the Supabase CLI/console:
--   SELECT storage.create_bucket('routine-assets', true);
-- Some Supabase projects include a helper function `storage.create_bucket`; if not available, create the bucket via the Supabase dashboard or CLI.

-- End of migration
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_279$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_280$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_280$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$anon_280$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at();

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at();

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;

-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_281$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
      ALTER TABLE public.tasks ADD COLUMN IF NOT EXISTS completed_at TIMESTAMPTZ;
    END IF;
END $anon_282$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_282$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_282$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_283$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_284$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_284$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_285$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_285$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_286$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_286$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_287$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

-- (duplicate demo-user profile block removed; earlier block above already creates/updates profile)
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_287$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_288$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_288$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$anon_288$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_289$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_290$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_290$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_290$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_291$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_292$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_292$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_293$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_293$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_294$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_294$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_295$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- (duplicate demo-user block removed)
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_295$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_296$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_296$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$anon_296$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_297$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_298$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_298$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_298$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_299$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_300$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_300$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_301$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_301$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_302$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_302$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_303$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- (duplicate demo-user block removed)
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_303$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_304$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_304$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$anon_304$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_305$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_305$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_306$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_306$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_307$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_307$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_308$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_308$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_309$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_309$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_310$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_310$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- (duplicate demo-user block removed)
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_311$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_311$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_312$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$anon_312$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_312$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_313$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_313$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_313$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_314$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_315$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_315$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_316$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_316$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_317$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_317$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_318$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- (duplicate demo-user block removed)
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_318$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_319$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_319$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$anon_319$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_320$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_320$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_321$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_321$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_322$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_322$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_323$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_323$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_324$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_324$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_325$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_325$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_326$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_326$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_327$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_327$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_328$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$anon_328$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_328$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_329$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_329$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_329$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_330$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_331$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_331$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_332$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_332$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_333$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_333$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_334$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_334$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_335$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_335$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_336$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_336$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$anon_336$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_337$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_337$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_338$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_338$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_339$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_339$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_340$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_340$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_341$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_341$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_342$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_342$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_343$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_343$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_344$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_344$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_345$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$anon_345$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_345$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_346$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_346$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_346$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_347$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_348$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_348$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_349$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_349$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_350$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_350$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_351$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_351$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_352$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_352$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_353$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_353$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_353$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_354$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_355$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_355$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_356$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_356$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_357$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_357$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_358$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_358$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_359$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_359$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_360$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_360$
BEGIN
  NEW.updated_at = NOW()
;

BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_361$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_361$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_362$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_362$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_363$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_363$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_364$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_364$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_365$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_365$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_366$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_366$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_367$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_367$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_368$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_368$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_369$
BEGIN
  NEW.updated_at = NOW()
;

BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_369$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_370$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_370$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_370$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_371$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_372$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_372$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_373$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_373$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_374$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_374$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_375$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_375$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_376$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_376$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_377$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_377$
BEGIN
  NEW.updated_at = NOW()
;

BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $anon_378$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $anon_378$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_379$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_379$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_380$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_380$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_381$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_381$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_382$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_382$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_383$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_383$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_384$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_384$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $anon_385$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$anon_385$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $anon_386$
BEGIN
  NEW.updated_at = NOW()
;

BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$anon_386$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO \$anon_395\$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END \$anon_395\$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $anon_387$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$anon_387$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $anon_388$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $anon_388$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $anon_389$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $anon_389$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $anon_390$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $anon_390$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $anon_394$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $anon_394$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $anon_392$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $anon_392$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;
;
-- Views for aggregating app_metrics
-- Created: 2025-11-20
-- Create views for `app_metrics` if the table exists. This avoids migration failures
-- when the views migration runs before the table migration in some deployment flows.
DO $$
BEGIN
  IF to_regclass('public.app_metrics') IS NOT NULL THEN
    -- Average elapsed time (ms) for matrix.initialize timers per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_avg_matrix_init_ms AS
      SELECT
        user_id,
        avg(((timer->>'end')::bigint - (timer->>'start')::bigint)) AS avg_init_ms,
        count(*) AS samples
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'timers') AS t(timer)
      WHERE (timer->>'label') = 'matrix.initialize' AND (timer->>'end') IS NOT NULL
      GROUP BY user_id;
    $VIEW$;

    -- Count of failure events per user (events with name containing 'failure')
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_failure_counts AS
      SELECT
        user_id,
        sum(CASE WHEN (event->>'name') IS NOT NULL AND (event->>'name') LIKE '%failure%' THEN 1 ELSE 0 END) AS failure_count
      FROM public.app_metrics,
        jsonb_array_elements(metrics->'events') AS e(event)
      GROUP BY user_id;
    $VIEW$;

    -- Last upload timestamp per user
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_last_upload_per_user AS
      SELECT
        user_id,
        max(created_at) as last_upload_at,
        count(*) as uploads
      FROM public.app_metrics
      GROUP BY user_id;
    $VIEW$;

    -- Simple activity: number of snapshots per day
    EXECUTE $VIEW$
      CREATE OR REPLACE VIEW public.view_metrics_daily_counts AS
      SELECT
        date_trunc('day', created_at) as day,
        count(*) as snapshots
      FROM public.app_metrics
      GROUP BY date_trunc('day', created_at)
      ORDER BY day DESC;
    $VIEW$;
  END IF;
END
$$;
;
-- Generated delta: only include statements missing from remote DB
-- Source: src/features/collaboration/database/schema.sql
-- Generated at 2025-11-20T21:07:10.265Z

CREATE EXTENSION IF NOT EXISTS "pg_cron"
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_email ON board_invitations(invitee_email)
;

CREATE INDEX IF NOT EXISTS idx_board_invitations_token ON board_invitations(access_token)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_board_id ON collaborative_tasks(board_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_tasks_owner_id ON collaborative_tasks(owner_id)
;

CREATE INDEX IF NOT EXISTS idx_collaborative_routines_board_id ON collaborative_routines(board_id)
;

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_board_id ON audit_logs(board_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id)
;

CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_board_id ON realtime_events(board_id)
;

CREATE INDEX IF NOT EXISTS idx_realtime_events_created_at ON realtime_events(created_at)
;

CREATE INDEX IF NOT EXISTS idx_user_presence_board_id ON user_presence(board_id)
;

ALTER TABLE collaborative_boards ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_collaborators ENABLE ROW LEVEL SECURITY
;

ALTER TABLE board_invitations ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_tasks ENABLE ROW LEVEL SECURITY
;

ALTER TABLE collaborative_routines ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE comment_reactions ENABLE ROW LEVEL SECURITY
;

ALTER TABLE task_attachments ENABLE ROW LEVEL SECURITY
;

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY
;

ALTER TABLE realtime_events ENABLE ROW LEVEL SECURITY
;

ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY
;

ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Owners can update boards" ON collaborative_boards
  FOR UPDATE USING (owner_id = auth.uid())
;

CREATE POLICY "Owners can delete boards" ON collaborative_boards
  FOR DELETE USING (owner_id = auth.uid())
;

CREATE POLICY "Users can create boards" ON collaborative_boards
  FOR INSERT WITH CHECK (owner_id = auth.uid())
;

CREATE POLICY "Board owners can manage collaborators" ON board_collaborators
  FOR ALL USING (
    board_id IN (SELECT id FROM collaborative_boards WHERE owner_id = auth.uid())
  )
;

CREATE POLICY "Users can create tasks in accessible boards" ON collaborative_tasks
  FOR INSERT WITH CHECK (
    board_id IN (
      SELECT id FROM collaborative_boards 
      WHERE owner_id = auth.uid() OR
      id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      )
    )
  )
;

CREATE POLICY "Users can update tasks they can edit" ON collaborative_tasks
  FOR UPDATE USING (
    owner_id = auth.uid() OR
    (
      board_id IN (
        SELECT board_id FROM board_collaborators 
        WHERE user_id = auth.uid() AND status = 'accepted' AND can_edit = true
      ) AND is_private = false
    )
  )
;

CREATE TRIGGER update_collaborative_boards_updated_at BEFORE UPDATE ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_tasks_updated_at BEFORE UPDATE ON collaborative_tasks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER update_collaborative_routines_updated_at BEFORE UPDATE ON collaborative_routines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()
;

CREATE TRIGGER add_board_owner_collaborator AFTER INSERT ON collaborative_boards FOR EACH ROW EXECUTE FUNCTION add_board_owner_as_collaborator()
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_board_id ON board_quick_lock(board_id)
;

CREATE INDEX IF NOT EXISTS idx_board_quick_lock_active ON board_quick_lock(is_active) WHERE is_active = TRUE
;

ALTER TABLE board_quick_lock ENABLE ROW LEVEL SECURITY
;

CREATE POLICY "Board owners can manage privacy settings" ON board_privacy_settings
  FOR ALL USING (
    board_id IN (
      SELECT id FROM collaborative_boards WHERE owner_id = auth.uid()
    )
  )
;

CREATE POLICY "Board collaborators with edit permissions can manage quick lock" ON board_quick_lock
  FOR ALL USING (
    board_id IN (
      SELECT bc.board_id FROM board_collaborators bc
      WHERE bc.user_id = auth.uid() 
      AND bc.status = 'accepted'
      AND bc.can_edit = TRUE
    )
  )
;

CREATE OR REPLACE FUNCTION update_board_quick_lock_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW()
;

CREATE TRIGGER trigger_update_board_privacy_settings_updated_at
  BEFORE UPDATE ON board_privacy_settings
  FOR EACH ROW EXECUTE FUNCTION update_board_privacy_settings_updated_at()
;

CREATE TRIGGER trigger_update_board_quick_lock_updated_at
  BEFORE UPDATE ON board_quick_lock
  FOR EACH ROW EXECUTE FUNCTION update_board_quick_lock_updated_at()
;

GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated
;

GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated
;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
;
;
-- QUICK MIGRATION RUNNER
-- Copy and paste this entire file into Supabase SQL Editor to apply all missing migrations
-- This is safe to run multiple times - it uses IF NOT EXISTS checks

-- =============================================
-- MIGRATION 006: MISSING TABLES
-- =============================================

-- TIME BLOCKS TABLE
CREATE TABLE IF NOT EXISTS public.time_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_rule JSONB,
    color TEXT DEFAULT '#3B82F6',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_time_blocks_user_id ON public.time_blocks(user_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_task_id ON public.time_blocks(task_id);
CREATE INDEX IF NOT EXISTS idx_time_blocks_start_time ON public.time_blocks(start_time);
CREATE INDEX IF NOT EXISTS idx_time_blocks_end_time ON public.time_blocks(end_time);

ALTER TABLE public.time_blocks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;
CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = time_blocks.user_id)
    ));

-- TASK TEMPLATES TABLE
CREATE TABLE IF NOT EXISTS public.task_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    category task_category NOT NULL,
    priority priority DEFAULT 'medium',
    estimated_duration INTEGER NOT NULL,
    tags TEXT[] DEFAULT '{}',
    energy_required energy_level DEFAULT 'medium',
    focus_required focus_level DEFAULT 'medium',
    sensory_considerations JSONB DEFAULT '[]',
    is_public BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_task_templates_user_id ON public.task_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_task_templates_category ON public.task_templates(category);
CREATE INDEX IF NOT EXISTS idx_task_templates_is_public ON public.task_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_task_templates_usage_count ON public.task_templates(usage_count DESC);

ALTER TABLE public.task_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own task templates" ON public.task_templates;
CREATE POLICY "Users can view own task templates"
    ON public.task_templates FOR SELECT
    USING (
        auth.uid() IN (
            SELECT id FROM auth.users 
            WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
        )
        OR is_public = true
    );

DROP POLICY IF EXISTS "Users can insert own task templates" ON public.task_templates;
CREATE POLICY "Users can insert own task templates"
    ON public.task_templates FOR INSERT
    WITH CHECK (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can update own task templates" ON public.task_templates;
CREATE POLICY "Users can update own task templates"
    ON public.task_templates FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

DROP POLICY IF EXISTS "Users can delete own task templates" ON public.task_templates;
CREATE POLICY "Users can delete own task templates"
    ON public.task_templates FOR DELETE
    USING (auth.uid() IN (
        SELECT id FROM auth.users 
        WHERE id IN (SELECT id FROM user_profiles WHERE id = task_templates.user_id)
    ));

-- =============================================
-- MIGRATION 007: SCHEMA UPDATES
-- =============================================

-- Add missing columns to tasks table
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at') THEN
        ALTER TABLE public.tasks ADD COLUMN scheduled_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration') THEN
        ALTER TABLE public.tasks ADD COLUMN actual_duration INTEGER;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time') THEN
        ALTER TABLE public.tasks ADD COLUMN buffer_time INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at') THEN
        ALTER TABLE public.tasks ADD COLUMN completed_at TIMESTAMPTZ;
    END IF;
END $$;

-- Add indexes for tasks
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON public.tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON public.tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON public.tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_scheduled_at ON public.tasks(scheduled_at) WHERE scheduled_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON public.tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_category ON public.tasks(category);

-- Update triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_time_blocks_updated_at ON public.time_blocks;
CREATE TRIGGER update_time_blocks_updated_at
    BEFORE UPDATE ON public.time_blocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_task_templates_updated_at ON public.task_templates;
CREATE TRIGGER update_task_templates_updated_at
    BEFORE UPDATE ON public.task_templates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- MIGRATION 008: PRIORITY MATRIX QUADRANT
-- =============================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'tasks' 
          AND column_name = 'quadrant'
    ) THEN
        ALTER TABLE public.tasks
          ADD COLUMN quadrant TEXT
          CHECK (quadrant IN (
            'urgent-important',
            'urgent-not-important',
            'not-urgent-important',
            'not-urgent-not-important'
          ))
          DEFAULT 'not-urgent-not-important';

        UPDATE public.tasks
        SET quadrant = CASE
          WHEN priority IN ('high', 'urgent') AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-important'
          WHEN priority IN ('high', 'urgent') AND (due_date IS NULL OR due_date > (NOW() + INTERVAL '2 days')) THEN 'not-urgent-important'
          WHEN (priority IS NULL OR priority NOT IN ('high', 'urgent')) AND due_date IS NOT NULL AND due_date <= (NOW() + INTERVAL '2 days') THEN 'urgent-not-important'
          ELSE 'not-urgent-not-important'
        END;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_tasks_quadrant ON public.tasks(quadrant);

-- =============================================
-- VERIFICATION
-- =============================================

-- Check if migrations were successful
DO $$
DECLARE
    time_blocks_exists BOOLEAN;
    task_templates_exists BOOLEAN;
    scheduled_at_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'time_blocks'
    ) INTO time_blocks_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_templates'
    ) INTO task_templates_exists;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'tasks' AND column_name = 'scheduled_at'
    ) INTO scheduled_at_exists;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'MIGRATION RESULTS:';
    RAISE NOTICE '========================================';
    
    IF time_blocks_exists THEN
        RAISE NOTICE ' time_blocks table created successfully';
    ELSE
        RAISE NOTICE ' time_blocks table FAILED to create';
    END IF;

    IF task_templates_exists THEN
        RAISE NOTICE ' task_templates table created successfully';
    ELSE
        RAISE NOTICE ' task_templates table FAILED to create';
    END IF;

    IF scheduled_at_exists THEN
        RAISE NOTICE ' tasks.scheduled_at column added successfully';
    ELSE
        RAISE NOTICE ' tasks.scheduled_at column FAILED to add';
    END IF;

    RAISE NOTICE '========================================';
    RAISE NOTICE 'Check the messages above for any failures.';
    RAISE NOTICE 'If you see  for all items, migrations are complete!';
    RAISE NOTICE '========================================';
END $$;
;
-- Quick check if migration 007 is needed
-- Run this to see what columns are missing from tasks table

SELECT 
    ' TASKS TABLE - Column Status' as check_type,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
        THEN ' scheduled_at EXISTS' ELSE ' scheduled_at MISSING' END as scheduled_at_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
        THEN ' actual_duration EXISTS' ELSE ' actual_duration MISSING' END as actual_duration_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
        THEN ' buffer_time EXISTS' ELSE ' buffer_time MISSING' END as buffer_time_status,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' completed_at EXISTS' ELSE ' completed_at MISSING' END as completed_at_status;

-- Check if all columns exist
SELECT 
    ' RECOMMENDATION' as action,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'scheduled_at')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'actual_duration')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'buffer_time')
         AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tasks' AND column_name = 'completed_at')
        THEN ' All columns exist! Migration 007 already applied or not needed.'
        ELSE ' Some columns missing. Run migration 007_schema_updates.sql OR RUN_ALL_MIGRATIONS.sql'
    END as recommendation;
;
-- Diagnostic: Check Demo User Status

-- Check if user exists and is confirmed
SELECT 
  id,
  email,
  email_confirmed_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed - Login should work'
    ELSE ' Email NOT Confirmed - Login will fail!'
  END as auth_status,
  created_at
FROM auth.users
WHERE email = 'demo@neurotypeplanner.com';

-- Check if profile exists
SELECT 
  CASE 
    WHEN EXISTS (SELECT 1 FROM public.user_profiles WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Profile exists'
    ELSE ' Profile missing - Run create_demo_user_SIMPLE.sql'
  END as profile_status;

-- Check if identity exists
SELECT 
  COUNT(*) as identity_count,
  CASE 
    WHEN COUNT(*) > 0 THEN ' Identity exists'
    ELSE ' Identity missing - User may not be able to login'
  END as identity_status
FROM auth.identities
WHERE user_id IN (SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com');
;
-- Create Demo User for Neurotype Planner
-- Run this in Supabase SQL Editor to create a demo user for testing

-- This script creates a demo user and their profile
-- Email: demo@neurotypeplanner.com
-- Password: demo123456

-- IMPORTANT: This SQL approach doesn't work due to auth.users constraints
-- You MUST create the user through the Supabase Dashboard UI:
-- 
-- 1. Go to Authentication  Users  Add User
-- 2. Enter email: demo@neurotypeplanner.com
-- 3. Enter password: demo123456
-- 4. Click "Create User"
-- 5. Then run the verification query below to get the user ID

-- After creating user in Dashboard, uncomment and run this to create their profile:


-- After creating user in Dashboard, uncomment and run this to create their profile:

-- Step 1: Get the user ID (run this after creating user in Dashboard)
SELECT 
  id,
  email,
  email_confirmed_at,
  created_at,
  CASE 
    WHEN email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email Not Confirmed'
  END as status
FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)
-- Step 2: Copy the user ID from above, then uncomment and run this:
-- (Replace 'PASTE_USER_ID_HERE' with the actual UUID from step 1)

/*
INSERT INTO public.user_profiles (
  id,
  email,
  display_name,
  neurotype,
  age_group,
  preferences
) VALUES (
  'PASTE_USER_ID_HERE', --  Replace with actual user ID from Step 1
  'demo@neurotypeplanner.com',
  'Demo User',
  'exploring',
  'adult',
  jsonb_build_object(
    'theme', 'light',
    'notifications_enabled', true,
    'default_view', 'dashboard'
  )
)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name;
*/

-- Step 3: Verify profile was created
SELECT 
  id,
  email,
  display_name,
  neurotype,
  age_group,
  created_at
FROM public.user_profiles
WHERE email = 'demo@neurotypeplanner.com';
;
-- Complete Demo User Creation Script
-- This creates BOTH the auth user AND the profile in one script

-- Create the user in auth.users using admin functions
DO $$
DECLARE
  demo_user_id UUID;
  demo_user_exists BOOLEAN;
BEGIN
  -- Check if user already exists
  SELECT EXISTS(
    SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
  ) INTO demo_user_exists;
  
  IF demo_user_exists THEN
    RAISE NOTICE 'User already exists, getting ID...';
    SELECT id INTO demo_user_id FROM auth.users WHERE email = 'demo@neurotypeplanner.com';
  ELSE
    -- Create new user with a random UUID
    demo_user_id := gen_random_uuid();
    
    -- Insert into auth.users
    INSERT INTO auth.users (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      recovery_token
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      demo_user_id,
      'authenticated',
      'authenticated',
      'demo@neurotypeplanner.com',
      crypt('demo123456', gen_salt('bf')),
      NOW(), -- Auto-confirm email
      '{"provider":"email","providers":["email"]}',
      '{}',
      NOW(),
      NOW(),
      '',
      ''
    );
    
    -- Also insert into auth.identities
    INSERT INTO auth.identities (
      id,
      user_id,
      provider_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      demo_user_id,
      demo_user_id::text, -- provider_id is the user_id as text
      jsonb_build_object('sub', demo_user_id::text, 'email', 'demo@neurotypeplanner.com'),
      'email',
      NOW(),
      NOW(),
      NOW()
    );
    
    RAISE NOTICE 'Created new user with ID: %', demo_user_id;
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE ' User profile created/updated successfully!';
END $$;
;
-- Verify everything was created correctly
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed'
  END as auth_status,
  up.display_name,
  up.neurotype,
  up.age_group,
  CASE
    WHEN up.id IS NOT NULL THEN ' Profile Created'
    ELSE ' Profile Missing'
  END as profile_status
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Create Demo User Profile for Neurotype Planner
-- Run this AFTER creating the user in Supabase Dashboard

-- STEP 1: First, create the user in Supabase Dashboard:
-- Go to Authentication  Users  Add User
-- Email: demo@neurotypeplanner.com
-- Password: demo123456
--  Check "Auto Confirm User"
-- Click "Create User"

-- STEP 2: Then run this entire script to create the user profile

-- Get the user ID first
DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID from auth.users
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  -- Check if user exists
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User demo@neurotypeplanner.com not found! Please create it in Dashboard first.';
  END IF;
  
  -- Create or update the user profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    jsonb_build_object(
      'theme', 'light',
      'notifications_enabled', true,
      'default_view', 'dashboard'
    )
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name,
    neurotype = EXCLUDED.neurotype,
    age_group = EXCLUDED.age_group,
    preferences = EXCLUDED.preferences;
  
  RAISE NOTICE 'User profile created successfully for user ID: %', demo_user_id;
END $$;
;
-- Verify the profile was created
SELECT 
  up.id,
  up.email,
  up.display_name,
  up.neurotype,
  up.age_group,
  au.email_confirmed_at,
  CASE 
    WHEN au.email_confirmed_at IS NOT NULL THEN ' Email Confirmed'
    ELSE ' Email NOT Confirmed - Auto-login will fail!'
  END as confirmation_status,
  up.created_at
FROM public.user_profiles up
JOIN auth.users au ON au.id = up.id
WHERE up.email = 'demo@neurotypeplanner.com';
;
-- SIMPLE Demo User Creation
-- This ONLY creates the profile for a user you create manually in the Dashboard

-- STEP 1: Create user manually in Supabase Dashboard:
-- 1. Go to Authentication  Users  Add User
-- 2. Email: demo@neurotypeplanner.com
-- 3. Password: demo123456
-- 4.  Check "Auto Confirm User"
-- 5. Click "Create User"

-- STEP 2: Run this script to create the profile

DO $$
DECLARE
  demo_user_id UUID;
BEGIN
  -- Get the user ID
  SELECT id INTO demo_user_id
  FROM auth.users
  WHERE email = 'demo@neurotypeplanner.com';
  
  IF demo_user_id IS NULL THEN
    RAISE EXCEPTION 'User not found! Create demo@neurotypeplanner.com in Dashboard first.';
  END IF;
  
  -- Create the profile
  INSERT INTO public.user_profiles (
    id,
    email,
    display_name,
    neurotype,
    age_group,
    preferences
  ) VALUES (
    demo_user_id,
    'demo@neurotypeplanner.com',
    'Demo User',
    'exploring',
    'adult',
    '{}'::jsonb
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = EXCLUDED.display_name;
  
  RAISE NOTICE ' Profile created for user: %', demo_user_id;
END $$;
;
-- Verify
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at IS NOT NULL as email_confirmed,
  up.display_name,
  up.neurotype
FROM auth.users au
LEFT JOIN public.user_profiles up ON up.id = au.id
WHERE au.email = 'demo@neurotypeplanner.com';
;
-- Delete Demo User (cleanup script)
-- Run this first to remove any partially created demo user

-- Delete from user_profiles first (foreign key)
DELETE FROM public.user_profiles 
WHERE email = 'demo@neurotypeplanner.com';

-- Delete from auth.identities
DELETE FROM auth.identities 
WHERE user_id IN (
  SELECT id FROM auth.users WHERE email = 'demo@neurotypeplanner.com'
);

-- Delete from auth.users
DELETE FROM auth.users 
WHERE email = 'demo@neurotypeplanner.com';

-- Verify deletion
SELECT 
  CASE 
    WHEN NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'demo@neurotypeplanner.com')
    THEN ' Demo user deleted successfully'
    ELSE ' Demo user still exists'
  END as status;
;
-- TEMPORARY: Disable RLS on tasks table for testing
-- WARNING: This removes security! Only for development/testing!

ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
;
-- Verify RLS is disabled
SELECT 
  tablename,
  rowsecurity,
  CASE 
    WHEN rowsecurity THEN ' RLS ENABLED (secure)'
    ELSE ' RLS DISABLED (insecure - testing only!)'
  END as status
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'tasks';

-- To re-enable later, run:
-- ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
;
-- Refresh Supabase Schema Cache and Fix Auth Issues

-- 1. Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';

-- 2. Check if auth schema is properly set up
SELECT 
  schemaname,
  tablename,
  COUNT(*) as column_count
FROM pg_tables pt
JOIN information_schema.columns c ON c.table_name = pt.tablename AND c.table_schema = pt.schemaname
WHERE schemaname = 'auth'
GROUP BY schemaname, tablename
ORDER BY tablename;

-- 3. Verify auth.users has all required columns
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'auth' 
AND table_name = 'users'
ORDER BY ordinal_position;
;
-- Fix RLS policies for time_blocks table
-- The original policies have overly complex nested queries that may cause 403 errors

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can insert own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can update own time blocks" ON public.time_blocks;
DROP POLICY IF EXISTS "Users can delete own time blocks" ON public.time_blocks;

-- Create simplified RLS policies
CREATE POLICY "Users can view own time blocks"
    ON public.time_blocks FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert own time blocks"
    ON public.time_blocks FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own time blocks"
    ON public.time_blocks FOR UPDATE
    USING (user_id = auth.uid());

CREATE POLICY "Users can delete own time blocks"
    ON public.time_blocks FOR DELETE
    USING (user_id = auth.uid());
;
-- Reload Supabase PostgREST Schema Cache
-- Run this if you get "Could not find the 'column_name' column" errors
-- This forces PostgREST to reload the database schema

-- Method 1: Send NOTIFY signal to reload schema
NOTIFY pgrst, 'reload schema';

-- Method 2: Alternative if above doesn't work
-- This requires superuser access (use Supabase Dashboard SQL Editor)
-- SELECT pg_reload_conf();

-- Verify tasks table schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'tasks' 
AND table_schema = 'public'
ORDER BY ordinal_position;
;
-- Database Schema Verification Script
-- Run this in Supabase SQL Editor to check what tables and columns exist
-- This helps identify what migrations still need to be applied

-- =============================================
-- 1. LIST ALL TABLES
-- =============================================
SELECT 
    table_name,
    CASE 
        WHEN table_name IN ('time_blocks', 'task_templates') THEN ' MISSING - Run migration 006'
        ELSE ' EXISTS'
    END as status
FROM information_schema.tables 
WHERE table_schema = 'public'
AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- =============================================
-- 2. CHECK TASKS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    column_default,
    CASE 
        WHEN column_name IN ('scheduled_at', 'actual_duration', 'buffer_time', 'completed_at') 
        THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'tasks'
ORDER BY ordinal_position;

-- =============================================
-- 3. CHECK BOARDS TABLE COLUMNS
-- =============================================
SELECT 
    column_name,
    data_type,
    is_nullable,
    CASE 
        WHEN column_name IN ('share_code', 'is_public') 
        THEN ' May be added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.columns 
WHERE table_name = 'boards'
ORDER BY ordinal_position;

-- =============================================
-- 4. CHECK IF TIME_BLOCKS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'time_blocks'
        ) 
        THEN ' time_blocks table EXISTS'
        ELSE ' time_blocks table MISSING - Run migration 006'
    END as time_blocks_status;

-- =============================================
-- 5. CHECK IF TASK_TEMPLATES TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'task_templates'
        ) 
        THEN ' task_templates table EXISTS'
        ELSE ' task_templates table MISSING - Run migration 006'
    END as task_templates_status;

-- =============================================
-- 6. CHECK IF NOTIFICATIONS TABLE EXISTS
-- =============================================
SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'notifications'
        ) 
        THEN ' notifications table EXISTS'
        ELSE ' notifications table MISSING - Will be created by migration 007'
    END as notifications_status;

-- =============================================
-- 7. CHECK RLS STATUS FOR NEW TABLES
-- =============================================
SELECT 
    tablename,
    CASE 
        WHEN rowsecurity THEN ' RLS ENABLED'
        ELSE ' RLS DISABLED'
    END as rls_status
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates', 'tasks', 'boards', 'notifications')
ORDER BY tablename;

-- =============================================
-- 8. COUNT INDEXES ON NEW TABLES
-- =============================================
SELECT 
    tablename,
    COUNT(*) as index_count,
    STRING_AGG(indexname, ', ' ORDER BY indexname) as indexes
FROM pg_indexes 
WHERE schemaname = 'public' 
AND tablename IN ('time_blocks', 'task_templates')
GROUP BY tablename
ORDER BY tablename;

-- =============================================
-- 9. CHECK CONSTRAINTS
-- =============================================
SELECT 
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    CASE 
        WHEN tc.constraint_name LIKE '%time_range%' THEN ' Added by migration 007'
        WHEN tc.constraint_name LIKE '%duration%' THEN ' Added by migration 007'
        ELSE ' Original'
    END as migration_status
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
AND tc.table_name IN ('tasks', 'time_blocks', 'task_templates')
ORDER BY tc.table_name, tc.constraint_type;

-- =============================================
-- 10. SUMMARY - WHAT NEEDS TO BE DONE
-- =============================================
SELECT 
    ' MIGRATION STATUS SUMMARY' as summary,
    CASE 
        WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'time_blocks')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_templates')
        THEN ' Migration 006 appears to be applied'
        ELSE ' Migration 006 NEEDS to be applied'
    END as migration_006_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'tasks' 
            AND column_name = 'scheduled_at'
        )
        THEN ' Migration 007 appears to be applied (or partially applied)'
        ELSE ' Migration 007 NEEDS to be applied'
    END as migration_007_status;

-- =============================================
-- INTERPRETATION GUIDE
-- =============================================
/*
WHAT TO DO BASED ON RESULTS:

1. If time_blocks_status shows "MISSING":
    Run migration 006_missing_tables.sql

2. If task_templates_status shows "MISSING":
    Run migration 006_missing_tables.sql

3. If tasks table is missing scheduled_at, actual_duration, etc.:
    Run migration 007_schema_updates.sql

4. If boards table is missing share_code or is_public:
    Run migration 007_schema_updates.sql (will add if missing)

5. If RLS shows "DISABLED" for any table:
    Check migration was applied correctly
    May need to manually enable RLS

6. If index_count is 0 for time_blocks or task_templates:
    Migration may not have completed successfully
    Re-run the migration

RECOMMENDED ORDER:
1. Run this verification script
2. Apply migration 006 if needed
3. Apply migration 007 if needed
4. Run this verification script again to confirm
*/
;